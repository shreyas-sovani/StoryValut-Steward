# **What is Frax USD (frxUSD)?**

frxUSD is a secure, stable, and scalable digital dollar live on over [20 blockchain networks](https://docs.frax.com/frxusd/frxusd-contracts).

frxUSD is fully backed by bankruptcy-remote, tokenized U.S. Treasury funds, managed by financial leaders such as BlackRock, Superstate, and WisdomTree. These institutional-grade custody services allow frxUSD to be mintable and redeemable 1:1 for U.S. dollars at each partner institution.

Frax publishes regular transparency reports and reserve balance sheets for frxUSD holdings on [Frax's Transparency page](https://frax.com/transparency).

## **frxUSD: The Future of Stable Digital Money**

Frax launched frxUSD to extend dollar access worldwide beyond the constraints of banking. By using public blockchain infrastructure, frxUSD delivers speed, safety, and efficiency that power meaningful improvements:

* Fully backed by tokenized U.S. Treasury assets  
* Live on over 20+ blockchain networks  
* Available 24/7/365  
* Earn 4.1% APY from Treasury yields (subject to treasury backing performance)

## **How to access frxUSD**

### **Minting frxUSD**

Using [FraxNet](https://net.frax.com/), access frxUSD to mint and redeem 1:1 using:

* USDC  
* PYUSD  
* USDT  
* USDB  
* Tokenized treasuries (BUIDL, USTB, WTGXX)

### **Earning with frxUSD**

Earn 4.1% APY from frxUSD's backing assets (Treasury bills) just by opening a [FraxNet](https://net.frax.com/) account and holding frxUSD in your non-custodial wallet.

Alternatively, [stake](https://frax.com/earn) frxUSD for sfrxUSD (Frax's savings product) to earn daily interest from tokenized institutional U.S. treasury fund reserves, Superstate's USCC, Ethena's USDe, and Sky's (formerly Maker) sUSDS.

To integrate frxUSD staking in your application, follow this [quickstart](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-evm-chains).

### **Trading frxUSD**

Get frxUSD on any decentralized exchanges:

* [Frax.com](https://frax.com/swap?tokenA=0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48&tokenB=0xcacd6fd266af91b8aed52accc382b4e165586e29&originChainId=1&destinationChainId=1)  
* [CoW Swap](https://swap.cow.fi/#/1/swap/USDC/frxUSD)  
* [Uniswap](https://app.uniswap.org/swap)  
* [Odos](https://app.odos.xyz/market)

## **Global Accessibility**

Currently live on over 20+ blockchain networks, frxUSD provides continuous market access 24 hours a day, 7 days a week. This always-available infrastructure enables efficient capital deployment and real-time settlement capabilities, meeting demands of modern financial operations. Powered by [FraxZero](https://docs.frax.com/frxusd/frax-zero) for cross-chain functionality.

Add frxUSD cross-chain transfers into your application in minutes. Follow these quickstarts:

* [Transfer frxUSD from EVM chains](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-evm)  
* [Transfer frxUSD from Solana](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-solana)  
* [Transfer frxUSD with Fraxtal](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-with-fraxtal)

## **frxUSD's Backing Assets**

### **USTB Details**

Superstate Short Duration US Government Securities Fund is a tokenized fund on the Ethereum network that offers Qualified Purchasers access to short-duration U.S. Treasury bills. [Learn more](https://superstate.com/ustb)

To integrate frxUSD minting and redeeming via USTB in your application, follow this [quickstart](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/ustb)

### **BUIDL Details**

BlackRock USD Institutional Digital Liquidity (BUIDL) Fund is a tokenized fund on the Ethereum network that is 100% backed by cash, U.S. Treasury bills, and repurchase agreements. [Learn more](https://securitize.io/learn/press/blackrock-launches-first-tokenized-fund-buidl-on-the-ethereum-network)

To integrate frxUSD minting and redeeming via BUIDL in your application, follow this [quickstart](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/buidl)

### **WisdomTree Details**

The WisdomTree Government Money Market Digital Fund is a tokenized fund on the Ethereum network that invests in high-quality, short-term instruments that may include investments such as Treasury bills, other U.S. government securities, and certificates of deposit. [Learn more](https://www.wisdomtree.com/investments/digital-funds/money-market/wtgxx)

To integrate frxUSD minting and redeeming via WTGXX in your application, follow this [quickstart](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/wtgxx)

### **USDB Details**

The USDB stablecoin is a GENIUS-compliant stablecoin issued by Bridge.xyz, a Stripe company, on the Ethereum and Solana networks that is backed by short-dated US Treasuries, overnight US Treasury repurchase agreements, money market funds, and cash that is held in a segregated account for the benefit of token holders and custodied by our partners at BlackRock, Fidelity, and Apex. [Learn more](https://www.bridge.xyz/)

To integrate frxUSD minting and redeeming via USDB in your application, follow this [quickstart](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdb)

## **Transparency**

Through partnerships with BlackRock and Superstate, frxUSD maintains full transparency of its U.S. Treasury fund reserves. Each frxUSD is backed by verifiable institutional-grade assets, with regular audits and reporting from industry-leading firms. You can view the reserve balance sheet for frxUSD at [Frax's Transparency page](https://frax.com/transparency)

## **Security**

frxUSD has undergone comprehensive security audits by leading blockchain security firm Zellic:

* [July 2025 \- frxUSD, frxUSDCustodian, FraxNetDeposit, and RWARedemptionCoordinator \- Zellic](https://github.com/FraxFinance/frax-solidity/blob/master/src/audits/Frax%20-%20Zellic%20Audit%20Report.pdf)

# **frxUSD Contract Addresses**

frxUSD is a secure, stable, and scalable digital dollar fully backed by bankruptcy-remote, tokenized U.S. Treasury funds.

The table below provides a comprehensive list of all blockchain networks frxUSD is live on:

### **Mainnet**

| Network | Address |
| ----- | ----- |
| Ethereum | [0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29](https://etherscan.io/address/0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29) |
| Fraxtal | [0xfc00000000000000000000000000000000000001](https://fraxscan.com/address/0xfc00000000000000000000000000000000000001) |
| Abstract | [0xEa77c590Bb36c43ef7139cE649cFBCFD6163170d](https://explorer.mainnet.abs.xyz/address/0xEa77c590Bb36c43ef7139cE649cFBCFD6163170d) |
| Aptos | [0xe4354602aa4311f36240dd57f3f3435ffccdbd0cd2963f1a69da39a2dbcd59b5](https://explorer.aptoslabs.com/fungible_asset/0xe4354602aa4311f36240dd57f3f3435ffccdbd0cd2963f1a69da39a2dbcd59b5?network=mainnet) |
| Arbitrum | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://arbiscan.io/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Aurora | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://aurorascan.dev/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Avalanche | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://snowtrace.io/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Base | [0xe5020A6d073a794B6E7f05678707dE47986Fb0b6](https://basescan.org/address/0xe5020A6d073a794B6E7f05678707dE47986Fb0b6) |
| Berachain | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://berascan.com/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Blast | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://blastscan.io/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| BSC | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://bscscan.com/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| HyperEVM | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://hyperevmscan.io/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Ink | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://explorer.inkonchain.com/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Katana | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://katanascan.com/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Linea | [0xC7346783f5e645aa998B106Ef9E7f499528673D8](https://lineascan.build/address/0xC7346783f5e645aa998B106Ef9E7f499528673D8) |
| Mode | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://explorer.mode.network/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Movement | [0xe4354602aa4311f36240dd57f3f3435ffccdbd0cd2963f1a69da39a2dbcd59b5](https://explorer.movementnetwork.xyz/fungible_asset/0xe4354602aa4311f36240dd57f3f3435ffccdbd0cd2963f1a69da39a2dbcd59b5?network=mainnet) |
| Optimism | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://optimistic.etherscan.io/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Plasma | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://plasmascan.to/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Plume | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://explorer.plume.org/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Polygon | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://polygonscan.com/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Polygon zkEVM | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://zkevm.polygonscan.com/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Scroll | [0x397F939C3b91A74C321ea7129396492bA9Cdce82](https://scrollscan.com/address/0x397F939C3b91A74C321ea7129396492bA9Cdce82) |
| Sei | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://seitrace.com/token/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Solana | [GzX1ireZDU865FiMaKrdVB1H6AE8LAqWYCg6chrMrfBw](https://solscan.io/account/GzX1ireZDU865FiMaKrdVB1H6AE8LAqWYCg6chrMrfBw) |
| Sonic | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://sonicscan.org/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Unichain | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://unichain.blockscout.com/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| Worldchain | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://worldscan.org/address/0x80Eede496655FB9047dd39d9f418d5483ED600df) |
| XLayer | [0x80Eede496655FB9047dd39d9f418d5483ED600df](https://www.oklink.com/x-layer/address/0x80eede496655fb9047dd39d9f418d5483ed600df) |
| zkSync | [0xEa77c590Bb36c43ef7139cE649cFBCFD6163170d](https://explorer.zksync.io/address/0xEa77c590Bb36c43ef7139cE649cFBCFD6163170d) |

### **Testnet**

| Network | Address |
| ----- | ----- |
| Holesky | [0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29](https://holesky.etherscan.io/address/0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29) |
| Fraxtal Testnet | [0xfc00000000000000000000000000000000000001](https://testnet.fraxscan.com/address/0xfc00000000000000000000000000000000000001) |

## **What's next**

* [FraxZero Overview](https://docs.frax.com/frxusd/frax-zero)  
* [Transfer frxUSD from EVM chains](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-evm)  
* [Transfer frxUSD from Solana](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-solana)  
* [Transfer frxUSD with Fraxtal](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-with-fraxtal)

# **FraxZero Overview**

FraxZero is Frax's cross-chain infrastructure that enables seamless asset movement and liquidity. Built on a robust hub-and-spoke architecture, FraxZero provides users with flexibility to interact with frxUSD and other Frax assets across 20+ blockchain networks.

## **Core Architecture**

### **Hub and Spoke Model**

FraxZero operates on a hub-and-spoke architecture where Fraxtal, Frax's native L1 EVM chain, serves as the central hub for all cross-chain operations. This design ensures:

* Centralized Liquidity Management: All bridged assets are routed through the Fraxtal Hub  
* Efficient Asset Routing: Optimized paths between [any supported chain](https://docs.frax.com/frxusd/fraxzero-supported-networks) for 1:1 cross-chain transfers  
* Unified Security Model: Consistent security standards across all connected networks

### **Multi-Chain Asset Support**

FraxZero supports 6 Frax assets across 20+ blockchain networks, including:

* frxUSD \- Frax's stablecoin  
* sfrxUSD \- Frax's yield-bearing stablecoin  
* WFRAX \- Frax's wrapped governance token  
* frxETH \- Frax's liquid staking derivative  
* sfrxETH \- Frax's staked liquid staking derivative  
* FPI \- Frax's price index stablecoin

## **Key Features**

### **Dual Lockbox System**

FraxZero implements a dual lockbox mechanism that:

* Unlocks Native Liquidity: Provides access to native Frax assets on multiple chains  
* Enhanced Security: Multiple security layers protect user assets during cross-chain transfers  
* Instant Availability: Assets are immediately available as native tokens on destination chains

### **Flexible Security Model**

The platform features a 3 of 3 Data Validation Network (DVN) requirement that includes:

* Frax Team-Run DVN: Direct oversight from Frax's security team  
* Multi-Party Validation: Distributed security across multiple validation networks  
* Configurable Requirements: Adaptable security parameters based on asset type and transfer size

### **Cross-Chain Asset Swapping**

FraxZero enables seamless asset swapping across chains with:

* Fraxtal Liquidity Access: Users can access Fraxtal's deep liquidity from [any supported chain](https://docs.frax.com/frxusd/fraxzero-supported-networks)  
* No Chain Hopping Required: Complete transactions without leaving the source network

## **Benefits for Users**

### **For Traders**

* Liquidity Access: Tap into Fraxtal's deep liquidity from [any supported chain](https://docs.frax.com/frxusd/fraxzero-supported-networks)  
* 1:1 Transfers: Transfers between chains are always 1:1  
* Faster Execution: Transfers are faster than traditional cross-chain transfers such as Circle's CCTP

### **For Developers**

* Simplified Integration: Easy-to-use APIs for cross-chain operations  
* Consistent Experience: Uniform interface across all supported networks  
* Security Assurance: Built-in security features reduce integration complexity

### **For Liquidity Providers**

* Cross-Chain Yield: Earn rewards across multiple networks  
* Risk Distribution: Spread liquidity across multiple chains  
* Enhanced Capital Efficiency: Optimize asset utilization across the ecosystem

## **Supported Networks**

FraxZero currently supports 20+ blockchain networks, providing comprehensive coverage across:

* Ethereum Mainnet and EVM Layer 2 solutions  
* Alternative Layer 1s including Solana  
* Frax-Native Networks like Fraxtal

## **What's next**

To begin using FraxZero, check out our [FraxZero Contracts](https://docs.frax.com/frxusd/fraxzero-supported-networks) and follow our quickstarts:

* [Transfer frxUSD from EVM chains](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-evm)  
* [Transfer frxUSD from Solana](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-solana)  
* [Transfer frxUSD with Fraxtal](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-with-fraxtal)

---

*FraxZero represents the future of cross-chain finance, bringing seamless asset movement and unified liquidity access to the entire Frax ecosystem.*

# **FraxZero Supported Networks and EIDs**

### **FraxZero RemoteHop Supported Networks**

frxUSD cross-chain transfers are available between the following networks using the RemoteHop method.

Note: If Ethereum mainnet is the source chain using the RemoteHop method, you must use the [Ethereum Lockbox address](https://docs.frax.com/frxusd/fraxzero-supported-networks#fraxzero-lockbox-supported-networks) for quote and send methods.

Follow our [Transfer frxUSD from EVM chains](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-evm) guide to see it in action.

| Mainnet | EID | RemoteHop Address |
| ----- | ----- | ----- |
| Ethereum | 30101 | [0x3ad4dC2319394bB4BE99A0e4aE2AbF7bCEbD648E](https://etherscan.io/address/0x3ad4dC2319394bB4BE99A0e4aE2AbF7bCEbD648E) |
| Abstract | 30324 | [0xc5e4a0cfef8d801278927c25fb51c1db7b69ddfb](https://explorer.mainnet.abs.xyz/address/0xc5e4a0cfef8d801278927c25fb51c1db7b69ddfb) |
| Arbitrum | 30110 | [0x29F5DBD0FE72d8f11271FCBE79Cb87E18a83C70A](https://arbiscan.io/address/0x29F5DBD0FE72d8f11271FCBE79Cb87E18a83C70A) |
| Aurora | 30211 | [0x53e36c8380ff62d7964bfa4868a0045e58a52344](https://aurorascan.dev/address/0x53e36c8380ff62d7964bfa4868a0045e58a52344) |
| Avalanche | 30106 | [0x7a07D606c87b7251c2953A30Fa445d8c5F856C7A](https://snowtrace.io/address/0x7a07D606c87b7251c2953A30Fa445d8c5F856C7A) |
| Base | 30184 | [0x3Ec3849C33291a9eF4c5dB86De593EB4A37fDe45](https://basescan.org/address/0x3Ec3849C33291a9eF4c5dB86De593EB4A37fDe45) |
| Berachain | 30362 | [0xc71BF5Ee4740405030eF521F18A96eA14fec802D](https://berascan.com/address/0xc71BF5Ee4740405030eF521F18A96eA14fec802D) |
| BSC | 30102 | [0x452420df4AC1e3db5429b5FD629f3047482C543C](https://bscscan.com/address/0x452420df4AC1e3db5429b5FD629f3047482C543C) |
| Ink | 30339 | [0x7a07D606c87b7251c2953A30Fa445d8c5F856C7A](https://explorer.inkonchain.com/address/0x7a07D606c87b7251c2953A30Fa445d8c5F856C7A) |
| Katana | 30375 | [0x5d8eb59a12bc98708702305a7b032f4b69dd5b5c](https://katanascan.com/address/0x5d8eb59a12bc98708702305a7b032f4b69dd5b5c) |
| Linea | 30183 | [0x6cA98f43719231d38F6426DB64C7F3D5C7CE7876](https://lineascan.build/address/0x6cA98f43719231d38F6426DB64C7F3D5C7CE7876) |
| Mode | 30260 | [0x486CB4788F1bE7cdEf9301a7a637B451df3Cf262](https://explorer.mode.network/address/0x486CB4788F1bE7cdEf9301a7a637B451df3Cf262) |
| Optimism | 30111 | [0x31D982ebd82Ad900358984bd049207A4c2468640](https://optimistic.etherscan.io/address/0x31D982ebd82Ad900358984bd049207A4c2468640) |
| Plume | 30370 | [0x6cA98f43719231d38F6426DB64C7F3D5C7CE7876](https://explorer.plume.org/address/0x6cA98f43719231d38F6426DB64C7F3D5C7CE7876) |
| Polygon | 30109 | [0xf74D38A26948E9DDa53eD85cF03C6b1188FbB30C](https://polygonscan.com/address/0xf74D38A26948E9DDa53eD85cF03C6b1188FbB30C) |
| Polygon zkEVM | 30158 | [0x111ddab65Af5fF96b674400246699ED40F550De1](https://zkevm.polygonscan.com/address/0x111ddab65Af5fF96b674400246699ED40F550De1) |
| Scroll | 30214 | [0xf6f45ccb5e85d1400067ee66f9e168f83e86124e](https://scrollscan.com/address/0xf6f45ccb5e85d1400067ee66f9e168f83e86124e) |
| Sei | 30280 | [0x3a6F28e8DDD232B02C72C491Bd1626F69D2fb329](https://seitrace.com/token/0x3a6F28e8DDD232B02C72C491Bd1626F69D2fb329) |
| Sonic | 30332 | [0x3A5cDA3Ac66Aa80573402610c94B74eD6cdb2F23](https://sonicscan.org/address/0x3A5cDA3Ac66Aa80573402610c94B74eD6cdb2F23) |
| Unichain | 30320 | [0xc71BF5Ee4740405030eF521F18A96eA14fec802D](https://unichain.blockscout.com/address/0xc71BF5Ee4740405030eF521F18A96eA14fec802D) |
| XLayer | 30274 | [0x79152c303AD5aE429eDefa4553CB1Ad2c6EE1396](https://www.oklink.com/x-layer/address/0x79152c303AD5aE429eDefa4553CB1Ad2c6EE1396) |
| zkSync | 30165 | [0xc5e4a0cfef8d801278927c25fb51c1db7b69ddfb](https://explorer.zksync.io/address/0xc5e4a0cfef8d801278927c25fb51c1db7b69ddfb) |

### **FraxZero Solana**

frxUSD cross-chain transfers from Solana to Ethereum or Fraxtal are supported.

Follow our [Transfer frxUSD from Solana](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-solana) guide to get started.

Note: frxUSD on Solana only has 9 decimals vs the typical 18 decimals on EVM chains.

| Mainnet | EID | Program ID | Mint | Escrow |
| ----- | ----- | ----- | ----- | ----- |
| Solana | 30168 | [E1ht9dUh1ZkgWWRRPCuN3kExEoF2FXiyADXeN3XyMHaQ](https://solscan.io/account/E1ht9dUh1ZkgWWRRPCuN3kExEoF2FXiyADXeN3XyMHaQ) | [GzX1ireZDU865FiMaKrdVB1H6AE8LAqWYCg6chrMrfBw](https://solscan.io/account/GzX1ireZDU865FiMaKrdVB1H6AE8LAqWYCg6chrMrfBw) | [84AFSH3TSzyjbEFJX9z8sjpV7npTWq7f8ZR5zkLG22hX](https://solscan.io/account/84AFSH3TSzyjbEFJX9z8sjpV7npTWq7f8ZR5zkLG22hX) |

### **FraxZero Lockbox Supported Networks**

frxUSD cross-chain transfers between Fraxtal and EVM chains are available using the Lockbox method.

Note: If Ethereum mainnet is the source chain using the RemoteHop method, you must use the [Ethereum Lockbox address](https://docs.frax.com/frxusd/fraxzero-supported-networks#fraxzero-lockbox-supported-networks) for quote and send methods.

Follow our [Transfer frxUSD with Fraxtal](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-with-fraxtal) guide to get started.

| Mainnet | EID | Lockbox Address |
| ----- | ----- | ----- |
| Ethereum | 30101 | [0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0](https://etherscan.io/address/0x3ad4dC2319394bB4BE99A0e4aE2AbF7bCEbD648E) |
| Fraxtal | 30255 | [0x96A394058E2b84A89bac9667B19661Ed003cF5D4](https://fraxscan.com/address/0x96A394058E2b84A89bac9667B19661Ed003cF5D4)  |

# **Transfer frxUSD from EVM chains**

This guide demonstrates how to use the viem framework in a simple script that enables a user to transfer frxUSD from any EVM-compatible chains listed on the [FraxZero RemoteHop addresses](https://docs.frax.com/frxusd/fraxzero-supported-networks) page using the RemoteHop method.

In this example, we will be transferring frxUSD from Ethereum mainnet to Arbitrum mainnet and vice versa.

Note: This guide does not support frxUSD transfers with Fraxtal and Solana as a source chain or Fraxtal as a destination chain. To support frxUSD transfers from Solana, see our [Transfer frxUSD from Solana](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-fraxtal) guide. To support frxUSD transfers from or to Fraxtal, see our [Transfer frxUSD with Fraxtal](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-fraxtal) guide.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token on the source chains  
   * For this guide, we will be transferring frxUSD from Ethereum mainnet and Arbitrum mainnet and vice versa. Therefore, you will need to fund your wallet with ETH on both networks.  
4. Fund your wallet with frxUSD on the source chain  
   * For this guide, we will be first transferring frxUSD from Ethereum mainnet to Arbitrum mainnet and vice versa. Therefore, you will need to [fund your wallet](https://frax.com/swap?tokenA=0x0000000000000000000000000000000000000000&tokenB=0xcacd6fd266af91b8aed52accc382b4e165586e29&originChainId=1&destinationChainId=1) with frxUSD on Ethereum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-cross-chain-transferscd frxusd-cross-chain-transfersnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frax-cross-chain-transfer",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node transfer.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the transfer.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key for PRIVATE\_KEY and associated wallet address for DESTINATION\_ADDRESS.

The script also predefines the RemoteHop contract addresses, the frxUSD contract addresses, the lockbox contract address (only for transfers from Ethereum using the RemoteHop method), the destination EIDs, and the transfer amount. These definitions are critical for successfully transferring frxUSD between the intended wallets.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // FILL IN THE FOLLOWING VARIABLEconst DESTINATION\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Recipient addressconst DESTINATION\_ADDRESS\_BYTES32 \= \`0x000000000000000000000000${DESTINATION\_ADDRESS.slice(2)}\`; // Convert to bytes32 format // RemoteHop Contract Addressesconst ETHEREUM\_MAINNET\_REMOTE\_HOP \= '0x3ad4dC2319394bB4BE99A0e4aE2AbF7bCEbD648E'; // RemoteHop contract address on source chainconst ARBITRUM\_MAINNET\_REMOTE\_HOP \= '0x29F5DBD0FE72d8f11271FCBE79Cb87E18a83C70A'; // RemoteHop contract address on destination chain // frxUSD Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD contract address on source chainconst ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS \= '0x80Eede496655FB9047dd39d9f418d5483ED600df'; // frxUSD contract address on destination chain // Lockbox Contract Addressconst ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS \= '0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0'; // When transferring from Ethereum to any other EVM chain (excluding Fraxtal) using the RemoteHop method, the Ethereum Lockbox address must be used for \`quote\` and \`send\` methods. // EIDs for destination chainsconst ARBITRUM\_MAINNET\_EID \= 30110; // EID of destination chain for first frxUSD transfer (Arbitrum mainnet)const ETHEREUM\_MAINNET\_EID \= 30101; // EID of destination chain for second frxUSD transfer (Ethereum mainnet) // Transfer Parameters for both frxUSD transfersconst TRANSFER\_AMOUNT \= 1\_000\_000\_000\_000\_000\_000n; // 1 frxUSD (18 decimals)

### **2\. Set up wallet and public clients**

The wallet client and public client configure the appropriate network settings using viem. In this example, the script will be transferring frxUSD from Ethereum mainnet to Arbitrum mainnet and vice versa.  
// Set up wallet clientsconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,});const arbitrumClient \= createWalletClient({  chain: arbitrum,  transport: http(),  account,}); // Set up public clientsconst ethereumPublicClient \= createPublicClient({  chain: mainnet,  transport: http(),});const arbitrumPublicClient \= createPublicClient({  chain: arbitrum,  transport: http(),});

## **frxUSD cross-chain transfer process**

The following sections outline the relevant transfer logic of the sample script. In this example, we are first transferring 1 frxUSD from Ethereum mainnet to Arbitrum mainnet. Then we are transferring 1 frxUSD back to Ethereum mainnet from Arbitrum mainnet. Follow the steps below to perform the transfer:

### **1\. Approve frxUSD**

For the first transfer from Ethereum mainnet to Arbitrum mainnet, grant approval for the [FraxZero RemoteHop contract](https://docs.frax.com/frxusd/frax-zero) deployed on Ethereum mainnet.

For the second transfer from Arbitrum mainnet to Ethereum mainnet, grant approval for the [FraxZero RemoteHop contract](https://docs.frax.com/frxusd/frax-zero) deployed on Arbitrum mainnet.

This allows the contracts to withdraw frxUSD from the specified wallet address on the source chains. For other EVM chains as a source chain, use the appropriate RemoteHop contract address from the [frxUSD RemoteHop addresses](https://docs.frax.com/frxusd/fraxzero-supported-networks) page.  
async function approveFrxUSD(sourceChainClient, frxUsdTokenAddress, remoteHopAddress) {  console.log('Approving frxUSD transfer...');  const approveTx \= await sourceChainClient.sendTransaction({    to: frxUsdTokenAddress,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[remoteHopAddress, TRANSFER\_AMOUNT\], // Set max allowance in wei (change as needed)    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} async function approveFrxUSDForEthereumToArbitrumTransfer() {  await approveFrxUSD(    ethereumClient,    ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    ETHEREUM\_MAINNET\_REMOTE\_HOP,  );} async function approveFrxUSDForArbitrumToEthereumTransfer() {  await approveFrxUSD(    arbitrumClient,    ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS,    ARBITRUM\_MAINNET\_REMOTE\_HOP,  );}

### **2\. Retrieve FraxZero Quote**

In this step, you call the quote function on the RemoteHop contracts deployed on Ethereum mainnet and Arbitrum mainnet to get the native fee amounts required for each respective transfer. You specify the following parameters:

* OFT: The contract address of the frxUSD token being transferred from the source chain. For transfers from Ethereum to Arbitrum or any other EVM chain (excluding Fraxtal), use the [Ethereum Lockbox address](https://docs.frax.com/frxusd/fraxzero-supported-networks#fraxzero-lockbox-supported-networks) instead of the frxUSD token address for this parameter.  
* Destination EID: The EID of the destination chain (EIDs can be found [here](https://docs.frax.com/frxusd/fraxzero-supported-networks))  
* Destination address: The wallet address that will receive the transferred frxUSD (in bytes32 format)  
* Amount: The amount of frxUSD to transfer (in wei)

The quote function returns the native fee amount required for the transfer.  
async function retrieveQuote(  sourceChainClient,  remoteHopAddress,  frxUsdTokenAddressOrEthereumLockboxAddress,  destinationEid,) {  console.log('Retrieving quote...');  const quote \= await sourceChainClient.readContract({    address: remoteHopAddress,    abi: \[      {        inputs: \[          { internalType: 'address', name: '\_oft', type: 'address' },          { internalType: 'uint32', name: '\_dstEid', type: 'uint32' },          { internalType: 'bytes32', name: '\_to', type: 'bytes32' },          { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },        \],        name: 'quote',        outputs: \[          {            components: \[              { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },              {                internalType: 'uint256',                name: 'lzTokenFee',                type: 'uint256',              },            \],            internalType: 'struct MessagingFee',            name: 'fee',            type: 'tuple',          },        \],        stateMutability: 'view',        type: 'function',      },    \],    functionName: 'quote',    args: \[      frxUsdTokenAddressOrEthereumLockboxAddress,      destinationEid,      DESTINATION\_ADDRESS\_BYTES32, // Use bytes32 format      TRANSFER\_AMOUNT,    \],  });  const nativeFee \= quote.nativeFee;  return nativeFee;}

### **3\. Transfer frxUSD**

After retrieving the native fee amounts, you can call the sendOFT function on the RemoteHop contracts deployed on Ethereum mainnet and Arbitrum mainnet to transfer frxUSD from Ethereum mainnet to Arbitrum mainnet and back to Ethereum mainnet. This function takes the following parameters:

* OFT: The contract address of the frxUSD token being transferred from the source chain. For transfers from Ethereum to Arbitrum or any other EVM chain (excluding Fraxtal), use the [Ethereum Lockbox address](https://docs.frax.com/frxusd/fraxzero-supported-networks#fraxzero-lockbox-supported-networks) instead of the frxUSD token address for this parameter.  
* Destination EID: The EID of the destination chain  
* Destination address: The wallet address that will receive the transferred frxUSD (in bytes32 format)  
* Amount: The amount of frxUSD to transfer (in wei)

async function transferFrxUSD(  sourceWalletClient,  sourcePublicClient,  remoteHopAddress,  frxUsdTokenAddressOrEthereumLockboxAddress,  destinationEid,) {  console.log('Transferring frxUSD...');  const nativeFee \= await retrieveQuote(    sourcePublicClient,    remoteHopAddress,    frxUsdTokenAddressOrEthereumLockboxAddress,    destinationEid,  );  const transferTx \= await sourceWalletClient.sendTransaction({    to: remoteHopAddress,    value: nativeFee,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'address', name: '\_oft', type: 'address' },            { internalType: 'uint32', name: '\_dstEid', type: 'uint32' },            { internalType: 'bytes32', name: '\_to', type: 'bytes32' },            { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },          \],          name: 'sendOFT',          outputs: \[\],          stateMutability: 'payable',          type: 'function',        },      \],      functionName: 'sendOFT',      args: \[        frxUsdTokenAddressOrEthereumLockboxAddress,        destinationEid,        DESTINATION\_ADDRESS\_BYTES32, // Use bytes32 format        TRANSFER\_AMOUNT,      \],    }),  });  console.log();  console.log(\`Transfer Tx: ${transferTx}\`);  console.log(\`View on LayerZero explorer: https://layerzeroscan.com/tx/${transferTx}\`);} // Here, because Ethereum mainnet is the source chain for this transfer using the RemoteHop method, we use the Ethereum Lockbox address instead of the frxUSD token address.async function transferFrxUSDForEthereumToArbitrum() {  await transferFrxUSD(    ethereumWalletClient,    ethereumPublicClient,    ETHEREUM\_MAINNET\_REMOTE\_HOP,    ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS, // Use lockbox address only when transferring from Ethereum to any other EVM chain (excluding Fraxtal)    ARBITRUM\_MAINNET\_EID,  );} // Here, because Ethereum mainnet is not the source chain for this transfer using the RemoteHop method, we use the frxUSD token address instead of the Ethereum Lockbox address.async function transferFrxUSDForArbitrumToEthereum() {  await transferFrxUSD(    arbitrumWalletClient,    arbitrumPublicClient,    ARBITRUM\_MAINNET\_REMOTE\_HOP,    ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS,    ETHEREUM\_MAINNET\_EID,  );}

## **Build the script**

Now that you understand the core steps for programmatically transferring frxUSD from Ethereum mainnet to Arbitrum mainnet using Frax's cross-chain infrastructure, create a transfer.js in your project directory and populate it with the sample code below.

Note: The source wallet must contain native mainnet ETH (to cover gas fees) and mainnet frxUSD to complete the transfer.

### **transfer.js**

// Import environment variablesimport 'dotenv/config';import {  createWalletClient,  createPublicClient,  http,  encodeFunctionData,  nonceManager,} from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet, arbitrum } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Recipient addressconst DESTINATION\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Enter your recipient wallet address hereconst DESTINATION\_ADDRESS\_BYTES32 \= \`0x000000000000000000000000${DESTINATION\_ADDRESS.slice(  2,)}\`; // Convert to bytes32 format // RemoteHop Contract Addressesconst ETHEREUM\_MAINNET\_REMOTE\_HOP \= '0x3ad4dC2319394bB4BE99A0e4aE2AbF7bCEbD648E'; // RemoteHop contract address on source chainconst ARBITRUM\_MAINNET\_REMOTE\_HOP \= '0x29F5DBD0FE72d8f11271FCBE79Cb87E18a83C70A'; // RemoteHop contract address on destination chain // frxUSD Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD contract address on source chainconst ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS \= '0x80Eede496655FB9047dd39d9f418d5483ED600df'; // frxUSD contract address on destination chain // Lockbox Contract Addressconst ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS \= '0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0'; // When transferring from Ethereum to any other EVM chain (excluding Fraxtal) using the RemoteHop method, the Ethereum Lockbox address must be used for \`quote\` and \`send\` methods. // EIDs for destination chainsconst ARBITRUM\_MAINNET\_EID \= 30110; // EID of destination chain for first frxUSD transfer (Arbitrum mainnet)const ETHEREUM\_MAINNET\_EID \= 30101; // EID of destination chain for second frxUSD transfer (Ethereum mainnet) // Transfer Parameters for both frxUSD transfersconst TRANSFER\_AMOUNT \= 1\_000\_000\_000\_000\_000\_000n; // 1 frxUSD (18 decimals) // Set up wallet clientsconst ethereumWalletClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,});const arbitrumWalletClient \= createWalletClient({  chain: arbitrum,  transport: http(),  account,}); // Set up public clientsconst ethereumPublicClient \= createPublicClient({  chain: mainnet,  transport: http(),});const arbitrumPublicClient \= createPublicClient({  chain: arbitrum,  transport: http(),}); async function approveFrxUSD(sourceChainClient, frxUsdTokenAddress, remoteHopAddress) {  console.log('Approving frxUSD transfer...');  const approveTx \= await sourceChainClient.sendTransaction({    to: frxUsdTokenAddress,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[remoteHopAddress, TRANSFER\_AMOUNT\], // Set max allowance in wei (change as needed)    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} async function approveFrxUSDForEthereumToArbitrumTransfer() {  await approveFrxUSD(    ethereumWalletClient,    ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    ETHEREUM\_MAINNET\_REMOTE\_HOP,  );} async function approveFrxUSDForArbitrumToEthereumTransfer() {  await approveFrxUSD(    arbitrumWalletClient,    ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS,    ARBITRUM\_MAINNET\_REMOTE\_HOP,  );}async function retrieveQuote(  sourceChainClient,  remoteHopAddress,  frxUsdTokenAddressOrEthereumLockboxAddress,  destinationEid,) {  console.log('Retrieving quote...');  const quote \= await sourceChainClient.readContract({    address: remoteHopAddress,    abi: \[      {        inputs: \[          { internalType: 'address', name: '\_oft', type: 'address' },          { internalType: 'uint32', name: '\_dstEid', type: 'uint32' },          { internalType: 'bytes32', name: '\_to', type: 'bytes32' },          { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },        \],        name: 'quote',        outputs: \[          {            components: \[              { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },              {                internalType: 'uint256',                name: 'lzTokenFee',                type: 'uint256',              },            \],            internalType: 'struct MessagingFee',            name: 'fee',            type: 'tuple',          },        \],        stateMutability: 'view',        type: 'function',      },    \],    functionName: 'quote',    args: \[      frxUsdTokenAddressOrEthereumLockboxAddress,      destinationEid,      DESTINATION\_ADDRESS\_BYTES32, // Use bytes32 format      TRANSFER\_AMOUNT,    \],  });  const nativeFee \= quote.nativeFee;  return nativeFee;} async function transferFrxUSD(  sourceWalletClient,  sourcePublicClient,  remoteHopAddress,  frxUsdTokenAddressOrEthereumLockboxAddress,  destinationEid,) {  console.log('Transferring frxUSD...');  const nativeFee \= await retrieveQuote(    sourcePublicClient,    remoteHopAddress,    frxUsdTokenAddressOrEthereumLockboxAddress,    destinationEid,  );  const transferTx \= await sourceWalletClient.sendTransaction({    to: remoteHopAddress,    value: nativeFee,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'address', name: '\_oft', type: 'address' },            { internalType: 'uint32', name: '\_dstEid', type: 'uint32' },            { internalType: 'bytes32', name: '\_to', type: 'bytes32' },            { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },          \],          name: 'sendOFT',          outputs: \[\],          stateMutability: 'payable',          type: 'function',        },      \],      functionName: 'sendOFT',      args: \[        frxUsdTokenAddressOrEthereumLockboxAddress,        destinationEid,        DESTINATION\_ADDRESS\_BYTES32, // Use bytes32 format        TRANSFER\_AMOUNT,      \],    }),  });  console.log();  console.log(\`Transfer Tx: ${transferTx}\`);  console.log(\`View on LayerZero explorer: https://layerzeroscan.com/tx/${transferTx}\`);} // Here, because Ethereum mainnet is the source chain for this transfer using the RemoteHop method, we use the Ethereum Lockbox address instead of the frxUSD token address.async function transferFrxUSDForEthereumToArbitrum() {  await transferFrxUSD(    ethereumWalletClient,    ethereumPublicClient,    ETHEREUM\_MAINNET\_REMOTE\_HOP,    ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS, // Use lockbox address only when transferring from Ethereum to any other EVM chain (excluding Fraxtal)    ARBITRUM\_MAINNET\_EID,  );} // Here, because Ethereum mainnet is not the source chain for this transfer using the RemoteHop method, we use the frxUSD token address instead of the Ethereum Lockbox address.async function transferFrxUSDForArbitrumToEthereum() {  await transferFrxUSD(    arbitrumWalletClient,    arbitrumPublicClient,    ARBITRUM\_MAINNET\_REMOTE\_HOP,    ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS,    ETHEREUM\_MAINNET\_EID,  );} async function main() {  if (DESTINATION\_ADDRESS \=== 'enter-your-recipient-wallet-address-here') {    console.error(      'Destination address is not set. Please set the DESTINATION\_ADDRESS variable in the transfer.js file.',    );    process.exit(1);  }  const command \= process.argv\[2\]; // Get command from CLI  switch (command) {    case 'ethereum-to-arbitrum':      console.log('Running Ethereum → Arbitrum transfer...');      await approveFrxUSDForEthereumToArbitrumTransfer();      await transferFrxUSDForEthereumToArbitrum();      break;    case 'arbitrum-to-ethereum':      console.log('Running Arbitrum → Ethereum transfer...');      await approveFrxUSDForArbitrumToEthereumTransfer();      await transferFrxUSDForArbitrumToEthereum();      break;    default:      console.error(        'Invalid command. Please use "ethereum-to-arbitrum" or "arbitrum-to-ethereum".',      );      process.exit(1);  }  console.log('Transfer completed\!');} main().catch(console.error);

The transfer.js script provides a complete end-to-end solution for transferring frxUSD using Frax's cross-chain infrastructure with a non-custodial wallet. In the next section, you can test the script.

## **Test the script**

To test the Ethereum to Arbitrum transfer, run the following command:  
node transfer.js ethereum-to-arbitrum

To test the Arbitrum to Ethereum transfer, run the following command:  
node transfer.js arbitrum-to-ethereum

Once each script runs and the transfer is finalized, a confirmation receipt and link on [LayerZero scan](https://layerzeroscan.com/) is logged in the console for each respective transfer. Each transfer takes approximately 4-5 minutes to complete.

## **What's next**

* [Transfer frxUSD from Solana](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-from-solana)  
* [Transfer frxUSD with Fraxtal](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-with-fraxtal)  
* 

# **Transfer frxUSD from Solana**

This guide demonstrates how to use the LayerZero V2 Solana OFT SDK, solana/web3.js, and Metaplex framework to enable users to transfer frxUSD from Solana to Ethereum and Fraxtal directly from their browser.

Note: This guide does not support frxUSD transfers where Solana is not the source chain. Ethereum mainnet and Fraxtal mainnet are the only destination chains supported if the source chain is Solana.

Important: The frxUSD token on Solana only has 9 decimals vs the typical 18 decimals on EVM chains.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer from Solana, ensure you have met the following prerequisites:

1. Create a React Vite or Next.js project  
2. Set up a non-custodial wallet on Phantom  
   * You can download, install, and create a Phantom wallet from its official website.  
   * During setup, create a wallet on Solana mainnet.  
3. Fund your wallet with the gas token SOL on Solana mainnet  
4. Fund your wallet with frxUSD on Solana mainnet  
   * For this guide, we will be transferring frxUSD from Solana mainnet to Ethereum mainnet and Fraxtal mainnet. Therefore, you will need to [fund your wallet](https://swap.pump.fun/?input=So11111111111111111111111111111111111111112&output=GzX1ireZDU865FiMaKrdVB1H6AE8LAqWYCg6chrMrfBw) with frxUSD on Solana mainnet.

## **Project setup**

To get started, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new React.js Typescript project with either Vite or Next.js:

This also creates a default package.json file.

### **3\. Solana OFT SDK dependencies setup**

Carefully follow all of the instructions in the [LayerZero V2 Solana OFT SDK](https://docs.layerzero.network/v2/developers/solana/oft/sdk) to setup and install the additional required dependencies and config for Vite or Next.js.  
*Note: It is recommended to use @solana/web3.js version ^1.98.0.*

### **4\. Install Solana wallet dependency**

In your project directory, run the following command to install the required dependencies:  
npm install @solana/wallet-adapter-react@^0.15.35 @solana/wallet-adapter-wallets@^0.19.32

## **SendOft.ts setup**

This section covers the necessary setup for the SendOft.ts file which includes the helper function for sending frxUSD from Solana to Ethereum mainnet and Fraxtal mainnet.

### **1\. Set up the file**

Create a new file called SendOft.ts in your project directory.

### **2\. Paste the following code**

import { publicKey, type Signer } from '@metaplex-foundation/umi';import { createUmi } from '@metaplex-foundation/umi-bundle-defaults';import {  safeFetchToken,  findAssociatedTokenPda,  mplToolbox,} from '@metaplex-foundation/mpl-toolbox';import {  ComputeBudgetProgram,  Connection,  PublicKey,  TransactionMessage,  VersionedTransaction,} from '@solana/web3.js';import { addressToBytes32 } from '@layerzerolabs/lz-v2-utilities';import { oft } from '@layerzerolabs/oft-v2-solana-sdk';import { toWeb3JsInstruction } from '@metaplex-foundation/umi-web3js-adapters'; // Replace with your Solana mainnet RPC URL https://www.helius.dev/export const SOLANA\_RPC\_URL \= 'https://example-mainnet.helius-rpc.com'; export async function sendOftFromSolana({  amount,  to,  toEid,  programId,  mint,  escrow,  userSigner,}: {  amount: bigint;  to: string;  toEid: number;  programId: string;  mint: string;  escrow: string;  userSigner: Signer;}) {  const frxUsdProgramId \= 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';  const umi \= createUmi(SOLANA\_RPC\_URL).use(mplToolbox());  const umiWalletSigner \= userSigner;  const oftProgramId \= publicKey(programId);  const oftMint \= publicKey(mint);  const oftEscrow \= publicKey(escrow);  const tokenProgramId \= publicKey(frxUsdProgramId);  const tokenAccount \= findAssociatedTokenPda(umi, {    mint: oftMint,    owner: userSigner.publicKey,    tokenProgramId,  });  console.log(tokenAccount);  if (\!tokenAccount) {    throw new Error(      \`No token account found for mint ${mint.toString()} and owner ${        umiWalletSigner.publicKey      } in program ${tokenProgramId}\`,    );  }  const tokenAccountData \= await safeFetchToken(umi, tokenAccount);  console.log(tokenAccountData);  const recipientAddressBytes32 \= addressToBytes32(to);  const { nativeFee } \= await oft.quote(    umi.rpc,    {      payer: userSigner.publicKey,      tokenMint: oftMint,      tokenEscrow: oftEscrow,    },    {      payInLzToken: false,      to: Buffer.from(recipientAddressBytes32),      dstEid: toEid,      amountLd: amount,      minAmountLd: (amount \* 99n) / 100n,      options: Buffer.from(''),      composeMsg: undefined,    },    {      oft: oftProgramId,    },  );  console.log(nativeFee);  const ix \= await oft.send(    umi.rpc,    {      payer: umiWalletSigner,      tokenMint: oftMint,      tokenEscrow: oftEscrow,      tokenSource: tokenAccount\[0\],    },    {      to: Buffer.from(recipientAddressBytes32),      dstEid: toEid,      amountLd: amount,      minAmountLd: (amount \* 99n) / 100n,      options: Buffer.from(''),      composeMsg: undefined,      nativeFee,    },    {      oft: oftProgramId,      token: tokenProgramId,    },  );  const connection \= new Connection(SOLANA\_RPC\_URL, 'confirmed');  const ALT\_ADDRESS \= new PublicKey('AokBxha6VMLLgf97B5VYHEtqztamWmYERBmmFvjuTzJB');  const { value: lookupTableAccount } \=    await connection.getAddressLookupTable(ALT\_ADDRESS);  if (\!lookupTableAccount) {    throw new Error('ALT not found');  }  const web3Instruction \= toWeb3JsInstruction(ix.instruction);  const computeBudgetIx \= ComputeBudgetProgram.setComputeUnitLimit({    units: 400000, // Increase to 400k units (default is 200k)  });  const { blockhash } \= await connection.getLatestBlockhash();  const messageV0 \= new TransactionMessage({    payerKey: new PublicKey(userSigner.publicKey),    recentBlockhash: blockhash,    instructions: \[computeBudgetIx, web3Instruction\],  }).compileToV0Message(\[lookupTableAccount\]);  const transaction \= new VersionedTransaction(messageV0);  return transaction;}

### **3\. Get your Solana RPC URL**

Replace the SOLANA\_RPC\_URL variable in the SendOft.ts file with your Solana RPC URL.  
export const SOLANA\_RPC\_URL \= 'https://example-mainnet.helius-rpc.com';

To get your Solana RPC URL, you can use a service like [Helius](https://www.helius.dev/).

## **TransferFrxusd.tsx setup**

This section covers the necessary setup for the TransferFrxusd.tsx file for transferring frxUSD from Solana to Ethereum and Fraxtal using the helper functions in the SendOft.ts file.

### **1\. Set up the file**

Create a new file called TransferFrxusd.tsx in your project directory.

### **2\. Paste the following code**

import { Connection } from '@solana/web3.js';import { parseUnits } from 'viem';import { sendOftFromSolana, SOLANA\_RPC\_URL } from './SendOft';import { useWallet } from '@solana/wallet-adapter-react';import { fromWeb3JsPublicKey } from '@metaplex-foundation/umi-web3js-adapters'; function TransferFrxusd() {  const { wallets, select, publicKey, signTransaction, disconnect } \= useWallet();  const phantomWallet \= wallets.find((wallet) \=\> wallet.adapter.name \=== 'Phantom');  if (\!phantomWallet) {    throw new Error('No Phantom wallet found');  }  const FRXUSD\_AMOUNT \= '0.1'; // Amount in frxUSD (e.g., 0.1 frxUSD)  const handleTransfer \= async (eid: number) \=\> {    if (\!publicKey || \!signTransaction) {      throw new Error('No public key found');    }    // Example constants for demonstration    const RECIPIENT\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Enter your recipient wallet address here    const DESTINATION\_CHAIN\_EID \= eid; // EID of the destination chain (either Ethereum mainnet or Fraxtal mainnet)    const SOLANA\_FRXUSD\_MINT \= 'GzX1ireZDU865FiMaKrdVB1H6AE8LAqWYCg6chrMrfBw'; // frxUSD mint on Solana    const SOLANA\_FRXUSD\_PROGRAM\_ID \= 'E1ht9dUh1ZkgWWRRPCuN3kExEoF2FXiyADXeN3XyMHaQ'; // frxUSD Program ID on Solana    const SOLANA\_FRXUSD\_ESCROW\_ADDRESS \= '84AFSH3TSzyjbEFJX9z8sjpV7npTWq7f8ZR5zkLG22hX'; // frxUSD escrow address on Solana    const tx \= await sendOftFromSolana({      // amount: The amount of frxUSD to transfer in wei (smallest unit)      // Convert the string amount to bigint using parseUnits with 9 decimals (frxUSD standard on Solana). NOTE: This is different from the standard on EVM chains (18 decimals).      amount: parseUnits(FRXUSD\_AMOUNT, 9),      // to: The recipient address on the destination chain (Ethereum/Fraxtal)      // Must be a valid EVM address (0x format)      to: RECIPIENT\_ADDRESS,      // toEid: The LayerZero endpoint ID of the destination chain      // 1 \= Ethereum mainnet, 2 \= Fraxtal, etc.      toEid: DESTINATION\_CHAIN\_EID,      // programId: The Solana program ID that handles the OFT operations      // This is typically the Solana Token Program for frxUSD transfers      programId: SOLANA\_FRXUSD\_PROGRAM\_ID,      // mint: The Solana mint address of the frxUSD token      // This identifies which token is being transferred      mint: SOLANA\_FRXUSD\_MINT,      // escrow: The escrow account address that temporarily holds tokens during transfer      // This is part of the LayerZero OFT protocol for cross-chain transfers      escrow: SOLANA\_FRXUSD\_ESCROW\_ADDRESS,      // userSigner: The wallet signer object that provides signing capabilities      // Contains publicKey and signing methods for transaction authorization      userSigner: {        publicKey: fromWeb3JsPublicKey(publicKey),        signTransaction: async (tx) \=\> tx,        signMessage: async (data) \=\> data,        signAllTransactions: async (txs) \=\> txs,      },    });    const signedTransaction \= await signTransaction(tx);    const connection \= new Connection(SOLANA\_RPC\_URL, 'confirmed');    const txid \= await connection.sendRawTransaction(signedTransaction.serialize());    console.log('Solana transaction ID:', txid);  };  const ETHEREUM\_MAINNET\_EID \= 30101;  const FRAXTAL\_MAINNET\_EID \= 30255;  return (    \<div      style={{        display: 'flex',        flexDirection: 'column',        gap: '10px',        margin: 'auto',      }}    \>      {\!publicKey ? (        \<button          onClick={() \=\> {            try {              select(phantomWallet.adapter.name);              phantomWallet.adapter.connect();            } catch (error) {              console.error('Failed to connect:', error);            }          }}        \>          Connect to Phantom Solana wallet        \</button\>      ) : (        \<button onClick={() \=\> disconnect()}\>Disconnect {publicKey.toString()}\</button\>      )}      \<button onClick={() \=\> handleTransfer(ETHEREUM\_MAINNET\_EID)}\>        Bridge {FRXUSD\_AMOUNT} frxUSD from Solana to Ethereum      \</button\>      \<button onClick={() \=\> handleTransfer(FRAXTAL\_MAINNET\_EID)}\>        Bridge {FRXUSD\_AMOUNT} frxUSD from Solana to Fraxtal      \</button\>    \</div\>  );} export default TransferFrxusd;

### **3\. Replace with your recipient wallet address**

Replace the RECIPIENT\_ADDRESS variable in the TransferFrxusd.tsx file with your recipient wallet address on Ethereum mainnet and Fraxtal mainnet.

## **App.tsx setup**

### **1\. Modify your App.tsx file in your project directory.**

'use client'; import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';import {  SolflareWalletAdapter,  PhantomWalletAdapter,} from '@solana/wallet-adapter-wallets';import { useMemo } from 'react';import TransferFrxusd from './TransferFrxusd';import { SOLANA\_RPC\_URL } from './SendOft'; function App() {  const wallets \= useMemo(() \=\> \[new PhantomWalletAdapter()\], \[\]);  return (    \<ConnectionProvider endpoint={SOLANA\_RPC\_URL}\>      \<WalletProvider wallets={wallets} autoConnect={true}\>        \<TransferFrxusd /\>      \</WalletProvider\>    \</ConnectionProvider\>  );} export default App;

### **2\. Test the code**

To test the code, run the following command:  
npm run dev

## **Parameter Reference**

The sendOftFromSolana function accepts the following parameters:

| Parameter | Type | Description | Example |
| ----- | ----- | ----- | ----- |
| amount | bigint | The amount of frxUSD to transfer . Use parseUnits() to convert from human-readable amounts. | parseUnits('100', 9\) for 100 frxUSD |
| to | string | The recipient address on the destination chain (Ethereum/Fraxtal). Must be a valid EVM address in 0x format. | 0xd8da6bf26964af9d7eed9e03e53415d37aa96045 |
| toEid | number | The LayerZero endpoint ID of the destination chain. | 30101 for Ethereum mainnet. 30255 for Fraxtal mainnet. |
| programId | string | The Solana program ID that handles the OFT operations. For frxUSD, this is typically the Solana Token Program. | E1ht9dUh1ZkgWWRRPCuN3kExEoF2FXiyADXeN3XyMHaQ |
| mint | string | The Solana mint address of the frxUSD token. This identifies which token is being transferred. | GzX1ireZDU865FiMaKrdVB1H6AE8LAqWYCg6chrMrfBw |
| escrow | string | The escrow account address that temporarily holds tokens during the cross-chain transfer process. | 84AFSH3TSzyjbEFJX9z8sjpV7npTWq7f8ZR5zkLG22hX |
| userSigner | Signer | The wallet signer object that provides signing capabilities for transaction authorization. | Wallet adapter signer object |

## **What's next**

* [Transfer frxUSD with Fraxtal](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts/transfer-with-fraxtal)  
* 

# **Transfer frxUSD with Fraxtal**

This guide demonstrates how to use the viem framework in a simple script that enables a user to transfer frxUSD with Fraxtal as the destination and source chain using the Lockbox addresses listed on the [FraxZero Lockbox addresses](https://docs.frax.com/frxusd/fraxzero-supported-networks).

In this example, we will be transferring frxUSD from Ethereum mainnet to Fraxtal mainnet, Fraxtal mainnet to Ethereum mainnet, and Arbitrum mainnet to Fraxtal mainnet.

Note: This guide does not support frxUSD transfers where Fraxtal is neither the source nor destination chain.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas tokens on the source chains  
   * For this guide, we will be transferring frxUSD from Ethereum mainnet, Arbitrum mainnet, and Fraxtal mainnet. Therefore, you will need to fund your wallet with ETH on Ethereum mainnet and Arbitrum mainnet, and FRAX on Fraxtal mainnet.  
4. Fund your wallet with frxUSD on the source chains  
   * For this guide, we will be transferring frxUSD from Ethereum mainnet, Arbitrum mainnet, and Fraxtal mainnet. Therefore, you will need to [fund your wallet](https://frax.com/swap) with frxUSD on each network.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-cross-chain-transfers-with-fraxtalcd frxusd-cross-chain-transfers-with-fraxtalnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frax-cross-chain-transfer",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node transfer.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the transfer.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key for PRIVATE\_KEY and associated wallet address for DESTINATION\_ADDRESS.

The script also predefines the Lockbox contract addresses, the frxUSD contract addresses, the destination EIDs, and the transfer amount. These definitions are critical for successfully transferring frxUSD between the intended wallets.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Recipient addressconst DESTINATION\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Enter your recipient wallet address hereconst DESTINATION\_ADDRESS\_BYTES32 \= \`0x000000000000000000000000${DESTINATION\_ADDRESS.slice(  2,)}\`; // Convert to bytes32 format // LockBox Contract Addresses and Destination EIDconst ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS \= '0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0'; // Lockbox contract address (used for Ethereum \-\> Fraxtal transfers)const FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS \= '0x96A394058E2b84A89bac9667B19661Ed003cF5D4'; // Lockbox contract address (used for Fraxtal \-\> Ethereum transfers) // frxUSD token contract addressesconst ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS \= '0x80Eede496655FB9047dd39d9f418d5483ED600df'; // frxUSD token contract address (used for Arbitrum \-\> Fraxtal transfers)const FRAXTAL\_MAINNET\_FRXUSD\_ADDRESS \= '0xfc00000000000000000000000000000000000001'; // frxUSD token contract address on Fraxtal mainnetconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD contract address on Ethereum mainnet // EIDs for destination chainsconst FRAXTAL\_MAINNET\_EID \= 30255; // EID of Fraxtal mainnetconst ETHEREUM\_MAINNET\_EID \= 30101; // EID of Ethereum mainnet // Transfer Parametersconst TRANSFER\_AMOUNT \= 1\_000\_000\_000\_000\_000\_000n; // 1 frxUSD (18 decimals)

### **2\. Set up wallet and public clients**

The wallet clients and public clients configure the appropriate network settings using viem. In this example guide, the script will be conducting the following frxUSD transfers:

* Ethereum mainnet to Fraxtal mainnet  
* Fraxtal mainnet to Ethereum mainnet  
* Arbitrum mainnet to Fraxtal mainnet

// Set up wallet clientsconst ethereumWalletClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); const fraxtalWalletClient \= createWalletClient({  chain: fraxtal,  transport: http(),  account,}); const arbitrumWalletClient \= createWalletClient({  chain: arbitrum,  transport: http(),  account,}); // Set up public clients for different chainsconst ethereumPublicClient \= createPublicClient({  chain: mainnet,  transport: http(),}); const fraxtalPublicClient \= createPublicClient({  chain: fraxtal,  transport: http(),}); const arbitrumPublicClient \= createPublicClient({  chain: arbitrum,  transport: http(),});

## **frxUSD transfer process with Fraxtal**

The following sections outline the relevant transfer logic of the sample script. In this example, we are conducting the following frxUSD transfers:

* 1 frxUSD from Ethereum mainnet to Fraxtal mainnet  
* 1 frxUSD from Fraxtal mainnet to Ethereum mainnet  
* 1 frxUSD from Arbitrum mainnet to Fraxtal mainnet

### **1\. Approve frxUSD**

The first step is to grant approval for the lockbox address. To determine the lockbox address to approve for each transfer, you can use the following table:

| Source Chain | Destination Chain | Lockbox Address |
| ----- | ----- | ----- |
| Ethereum | Fraxtal | ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS |
| Fraxtal | Ethereum (or other EVM chains) | FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS |
| Arbitrum (or other EVM chains excluding Fraxtal and Ethereum) | Fraxtal | NO APPROVAL REQUIRED |

Note: If the source chain is Arbitrum mainnet (or other EVM chains excluding Fraxtal and Ethereum) and the destination chain is Fraxtal mainnet, you do not need to approve the frxUSD token. However, if the source chain is Fraxtal mainnet and the destination chain is Arbitrum mainnet (or other EVM chains), you do need to approve the frxUSD token.  
async function approveFrxUSD(sourceChainClient, frxUsdTokenAddress, lockboxAddress) {  console.log('Approving frxUSD transfer...');  const approveTx \= await sourceChainClient.sendTransaction({    to: frxUsdTokenAddress,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[lockboxAddress, TRANSFER\_AMOUNT\], // Set max allowance in wei (change as needed)    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} async function approveFrxUSDForEthereumToFraxtalTransfer() {  await approveFrxUSD(    ethereumWalletClient,    ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS,  );} async function approveFrxUSDForFraxtalToEthereumTransfer() {  await approveFrxUSD(    fraxtalWalletClient,    FRAXTAL\_MAINNET\_FRXUSD\_ADDRESS,    FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS,  );}

### **2\. Retrieve FraxZero Quote**

In this step, you call the quoteSend function on the following depending on the transfer direction:

| Source Chain | Destination Chain | Address to call quoteSend on |
| ----- | ----- | ----- |
| Ethereum | Fraxtal | ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS |
| Fraxtal | Ethereum (or other EVM chains) | FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS |
| Arbitrum (or other EVM chains excluding Fraxtal and Ethereum) | Fraxtal | ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS |

Note: If the source chain is Arbitrum mainnet (or other EVM chains excluding Fraxtal and Ethereum) and the destination chain is Fraxtal mainnet, you simply use the frxUSD token address.

You then specify the following parameters:

* Destination EID: The EID of the destination chain (EIDs can be found [here](https://docs.frax.com/frxusd/fraxzero-supported-networks))  
* Destination address: The wallet address that will receive the transferred frxUSD (in bytes32 format)  
* Amount: The amount of frxUSD to transfer (in wei)  
* Minimum amount: The minimum amount of frxUSD to receive (in wei)  
* Extra options: The extra options for the transfer  
* Compose message: The compose message for the transfer  
* OFT command: The OFT command for the transfer

The quoteSend function returns the native fee amount required for the transfer.  
async function retrieveQuote(  sourceChainClient,  lockboxAddressOrFrxUsdTokenAddress,  destinationEid,) {  console.log('Retrieving quote...');  const quote \= await sourceChainClient.readContract({    address: lockboxAddressOrFrxUsdTokenAddress,    abi: \[      {        inputs: \[          {            components: \[              { internalType: 'uint32', name: 'dstEid', type: 'uint32' },              { internalType: 'bytes32', name: 'to', type: 'bytes32' },              { internalType: 'uint256', name: 'amountLD', type: 'uint256' },              {                internalType: 'uint256',                name: 'minAmountLD',                type: 'uint256',              },              { internalType: 'bytes', name: 'extraOptions', type: 'bytes' },              { internalType: 'bytes', name: 'composeMsg', type: 'bytes' },              { internalType: 'bytes', name: 'oftCmd', type: 'bytes' },            \],            internalType: 'struct SendParam',            name: '\_sendParam',            type: 'tuple',          },          { internalType: 'bool', name: '\_payInLzToken', type: 'bool' },        \],        name: 'quoteSend',        outputs: \[          {            components: \[              { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },              {                internalType: 'uint256',                name: 'lzTokenFee',                type: 'uint256',              },            \],            internalType: 'struct MessagingFee',            name: 'msgFee',            type: 'tuple',          },        \],        stateMutability: 'view',        type: 'function',      },    \],    functionName: 'quoteSend',    args: \[      {        dstEid: destinationEid,        to: DESTINATION\_ADDRESS\_BYTES32,        amountLD: TRANSFER\_AMOUNT,        minAmountLD: (TRANSFER\_AMOUNT \* 99n) / 100n,        extraOptions: '0x',        composeMsg: '0x',        oftCmd: '0x',      },      false,    \],  });  const nativeFee \= quote.nativeFee;  return nativeFee;}

### **3\. Transfer frxUSD**

After retrieving the native fee amounts, you can call the send function on the address you used in the prior step:

| Source Chain | Destination Chain | Address to call send on |
| ----- | ----- | ----- |
| Ethereum | Fraxtal | ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS |
| Fraxtal | Ethereum (or other EVM chains) | FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS |
| Arbitrum (or other EVM chains excluding Fraxtal and Ethereum) | Fraxtal | ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS |

Note: If the source chain is Arbitrum mainnet (or other EVM chains excluding Fraxtal and Ethereum) and the destination chain is Fraxtal mainnet, you simply use the frxUSD token address.

This function takes the following parameters:

* Destination EID: The EID of the destination chain  
* Destination address: The wallet address that will receive the transferred frxUSD (in bytes32 format)  
* Amount: The amount of frxUSD to transfer (in wei)  
* Minimum amount: The minimum amount of frxUSD to receive (in wei)  
* Extra options: The extra options for the transfer  
* Compose message: The compose message for the transfer  
* OFT command: The OFT command for the transfer  
* Native fee: The native fee for the transfer  
* Lz token fee: The lz token fee for the transfer  
* Refund address: The refund address for the transfer

async function transferFrxUSD(  sourceWalletClient,  sourcePublicClient,  lockboxAddressOrFrxUsdTokenAddress,  destinationEid,) {  console.log('Transferring frxUSD...');  const nativeFee \= await retrieveQuote(    sourcePublicClient,    lockboxAddressOrFrxUsdTokenAddress,    destinationEid,  );  const transferTx \= await sourceWalletClient.sendTransaction({    to: lockboxAddressOrFrxUsdTokenAddress,    value: nativeFee,    data: encodeFunctionData({      abi: \[        {          inputs: \[            {              components: \[                { internalType: 'uint32', name: 'dstEid', type: 'uint32' },                { internalType: 'bytes32', name: 'to', type: 'bytes32' },                { internalType: 'uint256', name: 'amountLD', type: 'uint256' },                { internalType: 'uint256', name: 'minAmountLD', type: 'uint256' },                { internalType: 'bytes', name: 'extraOptions', type: 'bytes' },                { internalType: 'bytes', name: 'composeMsg', type: 'bytes' },                { internalType: 'bytes', name: 'oftCmd', type: 'bytes' },              \],              internalType: 'struct SendParam',              name: '\_sendParam',              type: 'tuple',            },            {              components: \[                { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },                { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },              \],              internalType: 'struct MessagingFee',              name: '\_fee',              type: 'tuple',            },            { internalType: 'address', name: '\_refundAddress', type: 'address' },          \],          name: 'send',          outputs: \[            {              components: \[                { internalType: 'bytes32', name: 'guid', type: 'bytes32' },                { internalType: 'uint64', name: 'nonce', type: 'uint64' },                {                  components: \[                    { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },                    { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },                  \],                  internalType: 'struct MessagingFee',                  name: 'fee',                  type: 'tuple',                },              \],              internalType: 'struct MessagingReceipt',              name: 'msgReceipt',              type: 'tuple',            },            {              components: \[                { internalType: 'uint256', name: 'amountSentLD', type: 'uint256' },                {                  internalType: 'uint256',                  name: 'amountReceivedLD',                  type: 'uint256',                },              \],              internalType: 'struct OFTReceipt',              name: 'oftReceipt',              type: 'tuple',            },          \],          stateMutability: 'payable',          type: 'function',        },      \],      functionName: 'send',      args: \[        {          dstEid: destinationEid,          to: DESTINATION\_ADDRESS\_BYTES32,          amountLD: TRANSFER\_AMOUNT,          minAmountLD: (TRANSFER\_AMOUNT \* 99n) / 100n,          extraOptions: '0x',          composeMsg: '0x',          oftCmd: '0x',        },        { nativeFee: nativeFee, lzTokenFee: 0n },        account.address,      \],      value: nativeFee,    }),  });  console.log();  console.log(\`Transfer Tx: ${transferTx}\`);  console.log(\`View on LayerZero explorer: https://layerzeroscan.com/tx/${transferTx}\`);} // Here, because Ethereum mainnet is the source chain for this transfer to Fraxtal, we use the lockbox address instead of the frxUSD token address.async function transferFrxUSDForEthereumToFraxtal() {  await transferFrxUSD(    ethereumWalletClient,    ethereumPublicClient,    ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS,    FRAXTAL\_MAINNET\_EID,  );} // Here, because Fraxtal mainnet is the source chain for this transfer, we use the lockbox address instead of the frxUSD token address.async function transferFrxUSDForFraxtalToEthereum() {  await transferFrxUSD(    fraxtalWalletClient,    fraxtalPublicClient,    FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS,    ETHEREUM\_MAINNET\_EID,  );} // Here, because Arbitrum mainnet is the source chain for this transfer, we use the frxUSD token address instead of the lockbox address.async function transferFrxUSDForArbitrumToFraxtal() {  await transferFrxUSD(    arbitrumWalletClient,    arbitrumPublicClient,    ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS,    FRAXTAL\_MAINNET\_EID,  );}

## **Build the script**

Now that you understand the core steps for programmatically transferring frxUSD with Fraxtal as the source or destination chain using Frax's cross-chain infrastructure, create a transfer.js in your project directory and populate it with the sample code below.

Note: The source wallet must contain native gas tokens (to cover gas fees) and frxUSD to complete the transfer.

### **transfer.js**

// Import environment variablesimport 'dotenv/config';import {  createWalletClient,  createPublicClient,  http,  encodeFunctionData,  nonceManager,} from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet, arbitrum, fraxtal } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Recipient addressconst DESTINATION\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Enter your recipient wallet address hereconst DESTINATION\_ADDRESS\_BYTES32 \= \`0x000000000000000000000000${DESTINATION\_ADDRESS.slice(  2,)}\`; // Convert to bytes32 format // LockBox Contract Addresses and Destination EIDconst ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS \= '0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0'; // Lockbox contract address (used for Ethereum \-\> Fraxtal transfers)const FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS \= '0x96A394058E2b84A89bac9667B19661Ed003cF5D4'; // Lockbox contract address (used for Fraxtal \-\> Ethereum transfers) // frxUSD token contract addressesconst ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS \= '0x80Eede496655FB9047dd39d9f418d5483ED600df'; // frxUSD token contract address (used for Arbitrum \-\> Fraxtal transfers)const FRAXTAL\_MAINNET\_FRXUSD\_ADDRESS \= '0xfc00000000000000000000000000000000000001'; // frxUSD token contract address on Fraxtal mainnetconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD contract address on Ethereum mainnet // EIDs for destination chainsconst FRAXTAL\_MAINNET\_EID \= 30255; // EID of Fraxtal mainnetconst ETHEREUM\_MAINNET\_EID \= 30101; // EID of Ethereum mainnet // Transfer Parametersconst TRANSFER\_AMOUNT \= 10\_000\_000\_000\_000\_000n; // 1 frxUSD (18 decimals) // Set up wallet clientsconst ethereumWalletClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); const fraxtalWalletClient \= createWalletClient({  chain: fraxtal,  transport: http(),  account,}); const arbitrumWalletClient \= createWalletClient({  chain: arbitrum,  transport: http(),  account,}); // Set up public clients for different chainsconst ethereumPublicClient \= createPublicClient({  chain: mainnet,  transport: http(),}); const fraxtalPublicClient \= createPublicClient({  chain: fraxtal,  transport: http(),}); const arbitrumPublicClient \= createPublicClient({  chain: arbitrum,  transport: http(),}); async function approveFrxUSD(sourceChainClient, frxUsdTokenAddress, lockboxAddress) {  console.log('Approving frxUSD transfer...');  const approveTx \= await sourceChainClient.sendTransaction({    to: frxUsdTokenAddress,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[lockboxAddress, TRANSFER\_AMOUNT\], // Set max allowance in wei (change as needed)    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} async function approveFrxUSDForEthereumToFraxtalTransfer() {  await approveFrxUSD(    ethereumWalletClient,    ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS,  );} async function approveFrxUSDForFraxtalToEthereumTransfer() {  await approveFrxUSD(    fraxtalWalletClient,    FRAXTAL\_MAINNET\_FRXUSD\_ADDRESS,    FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS,  );} async function retrieveQuote(  sourceChainClient,  lockboxAddressOrFrxUsdTokenAddress,  destinationEid,) {  console.log('Retrieving quote...');  const quote \= await sourceChainClient.readContract({    address: lockboxAddressOrFrxUsdTokenAddress,    abi: \[      {        inputs: \[          {            components: \[              { internalType: 'uint32', name: 'dstEid', type: 'uint32' },              { internalType: 'bytes32', name: 'to', type: 'bytes32' },              { internalType: 'uint256', name: 'amountLD', type: 'uint256' },              {                internalType: 'uint256',                name: 'minAmountLD',                type: 'uint256',              },              { internalType: 'bytes', name: 'extraOptions', type: 'bytes' },              { internalType: 'bytes', name: 'composeMsg', type: 'bytes' },              { internalType: 'bytes', name: 'oftCmd', type: 'bytes' },            \],            internalType: 'struct SendParam',            name: '\_sendParam',            type: 'tuple',          },          { internalType: 'bool', name: '\_payInLzToken', type: 'bool' },        \],        name: 'quoteSend',        outputs: \[          {            components: \[              { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },              {                internalType: 'uint256',                name: 'lzTokenFee',                type: 'uint256',              },            \],            internalType: 'struct MessagingFee',            name: 'msgFee',            type: 'tuple',          },        \],        stateMutability: 'view',        type: 'function',      },    \],    functionName: 'quoteSend',    args: \[      {        dstEid: destinationEid,        to: DESTINATION\_ADDRESS\_BYTES32,        amountLD: TRANSFER\_AMOUNT,        minAmountLD: (TRANSFER\_AMOUNT \* 99n) / 100n,        extraOptions: '0x',        composeMsg: '0x',        oftCmd: '0x',      },      false,    \],  });  const nativeFee \= quote.nativeFee;  return nativeFee;} async function transferFrxUSD(  sourceWalletClient,  sourcePublicClient,  lockboxAddressOrFrxUsdTokenAddress,  destinationEid,) {  console.log('Transferring frxUSD...');  const nativeFee \= await retrieveQuote(    sourcePublicClient,    lockboxAddressOrFrxUsdTokenAddress,    destinationEid,  );  const transferTx \= await sourceWalletClient.sendTransaction({    to: lockboxAddressOrFrxUsdTokenAddress,    value: nativeFee,    data: encodeFunctionData({      abi: \[        {          inputs: \[            {              components: \[                { internalType: 'uint32', name: 'dstEid', type: 'uint32' },                { internalType: 'bytes32', name: 'to', type: 'bytes32' },                { internalType: 'uint256', name: 'amountLD', type: 'uint256' },                { internalType: 'uint256', name: 'minAmountLD', type: 'uint256' },                { internalType: 'bytes', name: 'extraOptions', type: 'bytes' },                { internalType: 'bytes', name: 'composeMsg', type: 'bytes' },                { internalType: 'bytes', name: 'oftCmd', type: 'bytes' },              \],              internalType: 'struct SendParam',              name: '\_sendParam',              type: 'tuple',            },            {              components: \[                { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },                { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },              \],              internalType: 'struct MessagingFee',              name: '\_fee',              type: 'tuple',            },            { internalType: 'address', name: '\_refundAddress', type: 'address' },          \],          name: 'send',          outputs: \[            {              components: \[                { internalType: 'bytes32', name: 'guid', type: 'bytes32' },                { internalType: 'uint64', name: 'nonce', type: 'uint64' },                {                  components: \[                    { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },                    { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },                  \],                  internalType: 'struct MessagingFee',                  name: 'fee',                  type: 'tuple',                },              \],              internalType: 'struct MessagingReceipt',              name: 'msgReceipt',              type: 'tuple',            },            {              components: \[                { internalType: 'uint256', name: 'amountSentLD', type: 'uint256' },                {                  internalType: 'uint256',                  name: 'amountReceivedLD',                  type: 'uint256',                },              \],              internalType: 'struct OFTReceipt',              name: 'oftReceipt',              type: 'tuple',            },          \],          stateMutability: 'payable',          type: 'function',        },      \],      functionName: 'send',      args: \[        {          dstEid: destinationEid,          to: DESTINATION\_ADDRESS\_BYTES32,          amountLD: TRANSFER\_AMOUNT,          minAmountLD: (TRANSFER\_AMOUNT \* 99n) / 100n,          extraOptions: '0x',          composeMsg: '0x',          oftCmd: '0x',        },        { nativeFee: nativeFee, lzTokenFee: 0n },        account.address,      \],      value: nativeFee,    }),  });  console.log();  console.log(\`Transfer Tx: ${transferTx}\`);  console.log(\`View on LayerZero explorer: https://layerzeroscan.com/tx/${transferTx}\`);} // Here, because Ethereum mainnet is the source chain for this transfer to Fraxtal, we use the lockbox address instead of the frxUSD token address.async function transferFrxUSDForEthereumToFraxtal() {  await transferFrxUSD(    ethereumWalletClient,    ethereumPublicClient,    ETHEREUM\_MAINNET\_LOCKBOX\_ADDRESS,    FRAXTAL\_MAINNET\_EID,  );} // Here, because Fraxtal mainnet is the source chain for this transfer, we use the lockbox address instead of the frxUSD token address.async function transferFrxUSDForFraxtalToEthereum() {  await transferFrxUSD(    fraxtalWalletClient,    fraxtalPublicClient,    FRAXTAL\_MAINNET\_LOCKBOX\_ADDRESS,    ETHEREUM\_MAINNET\_EID,  );} // Here, because Arbitrum mainnet is the source chain for this transfer, we use the frxUSD token address instead of the lockbox address.async function transferFrxUSDForArbitrumToFraxtal() {  await transferFrxUSD(    arbitrumWalletClient,    arbitrumPublicClient,    ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS,    FRAXTAL\_MAINNET\_EID,  );} async function main() {  if (DESTINATION\_ADDRESS \=== 'enter-your-recipient-wallet-address-here') {    console.error(      'Destination address is not set. Please set the DESTINATION\_ADDRESS variable in the transfer.js file.',    );    process.exit(1);  }  const command \= process.argv\[2\]; // Get command from CLI  switch (command) {    case 'ethereum-to-fraxtal':      console.log('Running Ethereum → Fraxtal transfer...');      await approveFrxUSDForEthereumToFraxtalTransfer();      await transferFrxUSDForEthereumToFraxtal();      break;    case 'fraxtal-to-ethereum':      console.log('Running Fraxtal → Ethereum transfer...');      await approveFrxUSDForFraxtalToEthereumTransfer();      await transferFrxUSDForFraxtalToEthereum();      break;    case 'arbitrum-to-fraxtal':      console.log('Running Arbitrum → Fraxtal transfer...');      await approveFrxUSDForFraxtalToEthereumTransfer();      await transferFrxUSDForFraxtalToEthereum();      break;    default:      console.error(        'Invalid command. Please use "ethereum-to-arbitrum" or "arbitrum-to-ethereum".',      );      process.exit(1);  }  console.log('Transfer completed\!');} main().catch(console.error);

The transfer.js script provides a complete end-to-end solution for transferring frxUSD using Frax's cross-chain infrastructure with a non-custodial wallet. In the next section, you can test the script.

## **Test the script**

To test the Ethereum to Fraxtal transfer, run the following command:  
node transfer.js ethereum-to-fraxtal

To test the Fraxtal to Ethereum transfer, run the following command:  
node transfer.js fraxtal-to-ethereum

To test the Arbitrum to Fraxtal transfer, run the following command:  
node transfer.js arbitrum-to-fraxtal

Once each script runs and the transfer is finalized, a confirmation receipt and link on [LayerZero scan](https://layerzeroscan.com/) is logged in the console for each respective transfer. Each transfer takes approximately 4-5 minutes to complete.

## **What's next**

* [Mint & Redeem frxUSD](https://docs.frax.com/frxusd/mint-and-redeem-overview)  
* 

# **Mint & Redeem frxUSD Overview**

frxUSD can be minted and redeemed through multiple pathways, offering users flexibility in how they access and utilize the stablecoin. This overview covers the main minting and redemption methods available.

## **frxUSD Minting & Redeeming on Ethereum**

The most straightforward way to mint and redeem frxUSD is through direct interaction with the frxUSD Mint & Redeem contracts on Ethereum mainnet.

### **Supported Assets for Minting**

frxUSD can be minted using any of these assets:

* Stablecoins: USDC, USDB  
* Tokenized Treasuries: BUIDL (by BlackRock), USTB (by Superstate), WTGXX (by WisdomTree)

### **How It Works**

1. Approve your asset for the frxUSD minting contract  
2. Deposit your asset to mint frxUSD at a 1:1 ratio  
3. Hold frxUSD to earn Treasury yields automatically via [FraxNet](https://net.frax.com/)  
4. Redeem anytime by converting frxUSD back to your chosen asset

Get started with the following quickstarts:

* [Mint and redeem with USDC](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdc)  
* [Mint and redeem with Superstate's USTB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/ustb)  
* [Mint and redeem with Blackrock's BUIDL](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/buidl)  
* [Mint and redeem with WisdomTree's WTGXX](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/wtgxx)  
* [Mint and redeem with Bridge.xyz's USDB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdb)

## **Cross-Chain Minting & Redeeming with FraxNet**

### **Overview**

If users want to mint and redeem frxUSD on any of the other [supported blockchain networks](https://docs.frax.com/frxusd/mint-and-redeem-routes), they can use the FraxNet contract system which leverages [FraxZero's cross-chain messaging protocol](https://docs.frax.com/frxusd/frax-zero).

### **Key Benefits**

* Asset Flexibility: Mint frxUSD on any of the [supported blockchain networks](https://docs.frax.com/frxusd/mint-and-redeem-routes)  
* Gas Optimization: Choose the most cost-effective network for your operations  
* Unified Experience: Manage cross-chain operations through a single interface  
* Institutional Grade: Built on [FraxZero's cross-chain messaging protocol](https://docs.frax.com/frxusd/frax-zero)

### **How Cross-Chain Minting Works**

Mint frxUSD across 20+ supported blockchain networks with the following steps:

1. Contract Deployment: Deploy a FraxNet contract via the factory on Ethereum mainnet for a specific recipient address and destination chain  
2. Asset Transfer: Transfer USDC directly to your deployed FraxNet contract on Ethereum mainnet  
3. Cross-Chain Minting: Using the transferred USDC, mint frxUSD to the specified recipient address and destination chain

### **How Cross-Chain Redemption Works**

Redeem frxUSD on 20+ supported blockchain networks with the following steps:

1. Cross-Chain Transfer: Send frxUSD on any supported blockchain network back to your FraxNet contract on Ethereum mainnet via a [cross-chain transfer](https://docs.frax.com/frxusd/cross-chain-transfers-quickstarts)  
2. Asset Conversion: Call processRedemption to convert frxUSD back to USDC  
3. Asset Delivery: Receive USDC directly to your specified address on Ethereum mainnet or any [supported CCTP chains](https://developers.circle.com/cctp/cctp-supported-blockchains)

## **Getting Started**

### **Supported Blockchain Networks**

* [Supported Routes & Networks](https://docs.frax.com/frxusd/mint-and-redeem-routes)

### **Quick Start Guides**

* [Mint & Redeem frxUSD with USDC](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdc)  
* [Mint & Redeem frxUSD with USTB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/ustb)  
* [Mint & Redeem frxUSD with BUIDL](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/buidl)  
* [Mint & Redeem frxUSD with WTGXX](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/wtgxx)  
* [Mint & Redeem frxUSD with USDB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdb)  
* [Mint & Redeem frxUSD Cross-Chain](https://docs.frax.com/frxusd/cross-chain-mint-and-redeem-quickstart)  
* 

# **frxUSD Mint & Redeem Supported Routes & Networks**

Mint and redeem frxUSD 1:1 on any of the supported blockchain networks below.

## **Mint & Redeem Routes on Ethereum**

The following table shows the supported assets you can use to mint and redeem frxUSD 1:1 on Ethereum mainnet, along with their token addresses and the corresponding Mint & Redeem contracts.

Note: Please ensure the sender and recipient addresses are onboarded to hold BUIDL, USTB, or WTGXX in order to mint and redeem frxUSD using these assets.

| Asset | Asset Address | Mint & Redeem Contract | Issuer |
| ----- | ----- | ----- | ----- |
| USDC | [0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48](https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48) | [0x4F95C5bA0C7c69FB2f9340E190cCeE890B3bd87c](https://etherscan.io/address/0x4F95C5bA0C7c69FB2f9340E190cCeE890B3bd87c) | Circle Internet Group, Inc. |
| USTB | [0x43415eb6ff9db7e26a15b704e7a3edce97d31c4e](https://etherscan.io/address/0x43415eb6ff9db7e26a15b704e7a3edce97d31c4e) | [0x5fbAa3A3B489199338fbD85F7E3D444dc0504F33](https://etherscan.io/address/0x5fbAa3A3B489199338fbD85F7E3D444dc0504F33) | Superstate Inc. |
| BUIDL | [0x7712c34205737192402172409a8f7ccef8aa2aec](https://etherscan.io/address/0x7712c34205737192402172409a8f7ccef8aa2aec) | [0xe827abf9f462ac4f147753d86bc5f91e186e4e9c](https://etherscan.io/address/0xe827abf9f462ac4f147753d86bc5f91e186e4e9c) | BlackRock, Inc. |
| WTGXX | [0x1fecf3d9d4fee7f2c02917a66028a48c6706c179](https://etherscan.io/address/0x1fecf3d9d4fee7f2c02917a66028a48c6706c179) | [0x860Cc723935FC9A15fF8b1A94237a711DFeF7857](https://etherscan.io/address/0x860Cc723935FC9A15fF8b1A94237a711DFeF7857) | WisdomTree, Inc. |
| USDB | [0xeac4269c9a01190b1400c4dc728864e61895fdf3](https://etherscan.io/address/0xeac4269c9a01190b1400c4dc728864e61895fdf3) | [0xFE2Ea8dE262d956e852F12DE108fda57171a0a29](https://etherscan.io/address/0xFE2Ea8dE262d956e852F12DE108fda57171a0a29) | Bridge.xyz |

### **Quickstart Guides**

* [Mint and redeem with USDC](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdc)  
* [Mint and redeem with Superstate's USTB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/ustb)  
* [Mint and redeem with Blackrock's BUIDL](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/buidl)  
* [Mint and redeem with WisdomTree's WTGXX](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/wtgxx)  
* [Mint and redeem with Bridge.xyz's USDB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdb)

## **Cross-Chain Mint & Redeem Routes**

The FraxNet contract system allows for cross-chain frxUSD mint & redeem operations. This system enables minting and redeeming frxUSD across multiple networks using USDC. The same factory contract powers [FraxNet](https://net.frax.com/):

| Mainnet | FraxNet Factory Address |
| ----- | ----- |
| Ethereum | [0xA3D62f83C433e2A56Af392E08a705A52DEd63696](https://etherscan.io/address/0xA3D62f83C433e2A56Af392E08a705A52DEd63696) |

Follow the [quickstart guide](https://docs.frax.com/frxusd/cross-chain-mint-and-redeem-quickstart) to see it in action.

### **Supported Chains for Minting**

Below are the supported chains you can receive newly minted frxUSD on:

| Mainnet | EID |
| ----- | ----- |
| Ethereum | 30101 |
| Abstract | 30324 |
| Arbitrum | 30110 |
| Aurora | 30211 |
| Avalanche | 30106 |
| Base | 30184 |
| Berachain | 30362 |
| BSC | 30102 |
| Ink | 30339 |
| Katana | 30375 |
| Linea | 30183 |
| Mode | 30260 |
| Optimism | 30111 |
| Plume | 30370 |
| Polygon | 30109 |
| Polygon zkEVM | 30158 |
| Scroll | 30214 |
| Sei | 30280 |
| Sonic | 30332 |
| Unichain | 30320 |
| XLayer | 30274 |
| zkSync | 30165 |

### **Supported Chains for Redeeming**

Below are the supported chains you can receive USDC on via [Circle's CCTP V2](https://developers.circle.com/cctp/cctp-supported-blockchains) after redeeming frxUSD:

Important: CCTP V1 is not supported.

Note: If you want to redeem frxUSD and receive USDC on Ethereum mainnet, there is no need to use CCTP V2. You can simply call processRedemption to redeem frxUSD back to USDC directly on Ethereum mainnet.

| Mainnet | Domain |
| ----- | ----- |
| Avalanche | 1 |
| Optimism | 2 |
| Arbitrum | 3 |
| Solana | 5 |
| Base | 6 |
| Polygon PoS | 7 |
| Unichain | 10 |
| Linea | 11 |
| Sonic | 13 |
| Sei | 16  |

# **Mint & Redeem frxUSD with USDC**

This guide demonstrates how to use the viem framework in a simple script that enables a user to mint and redeem frxUSD with USDC on Ethereum mainnet.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token and USDC on the source chain  
   * For this guide, we will be minting and redeeming frxUSD with USDC on Ethereum mainnet. Therefore, you will need to fund your wallet with USDC and ETH on Ethereum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-mint-and-redeem-with-usdccd frxusd-mint-and-redeem-with-usdcnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frax-mint-and-redeem-with-usdc",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node mint-and-redeem.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the mint-and-redeem.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key and associated wallet address. The script also predefines the Mint & Redeem contract address, the frxUSD address, the USDC address, the mint amount, and the redeem amount. These definitions are critical for successfully minting and redeeming frxUSD between the intended wallets.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addresses and Destination EIDconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN \=  '0x4F95C5bA0C7c69FB2f9340E190cCeE890B3bd87c'; // Mint & Redeem contract address using USDC // frxUSD and USDC Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_USDC\_ADDRESS \= '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'; // USDC address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 USDCconst REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD

### **2\. Set up wallet client**

The wallet client configures the appropriate network settings using viem. In this example, the script will be minting and redeeming frxUSD with USDC on Ethereum mainnet.  
// Set up a wallet client on the source chainconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,});

## **frxUSD mint & redeem process**

The following sections outline the relevant mint & redeem logic of the sample script. In this example, we are minting and redeeming frxUSD with USDC on Ethereum mainnet. Follow the steps below to perform the mint & redeem:

### **1\. Approve USDC & frxUSD**

Before minting, approve USDC for the [Mint & Redeem contract](https://docs.frax.com/frxusd/frax-zero) on Ethereum mainnet so it can pull USDC from your wallet. Before redeeming, approve frxUSD for the same contract so it can pull frxUSD. For other assets, use the appropriate contract address from the [frxUSD Mint & Redeem addresses](https://docs.frax.com/frxusd/mint-and-redeem-routes) page.  
async function approveUsdcForMint() {  console.log('Approving USDC for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_USDC\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`USDC Approval Tx: ${approveTx}\`);} async function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);}

* Both approvals are now explicit: approve USDC for mint, approve frxUSD for redeem, both to ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN.

### **2\. Mint frxUSD with USDC**

After approving USDC, mint by calling the Mint & Redeem contract's deposit to receive frxUSD.  
async function mintFrxusdWithUsdc() {  console.log('Minting frxUSD with USDC...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);}

* Call await approveUsdcForMint() first, then await mintFrxusdWithUsdc().

### **3\. Redeem frxUSD with USDC**

After approving frxUSD, redeem by calling the Mint & Redeem contract's redeem to receive USDC.  
async function redeemFrxusdForUsdc() {  console.log('Redeeming frxUSD for USDC...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);}

* Call await approveFrxusdForRedeem() first, then await redeemFrxusdForUsdc().

## **Build the script**

Create a mint-and-redeem.js in your project directory and paste the following. It groups the script setup and helper functions together at the top, followed by the main execution flow.

Note: The wallet must contain mainnet ETH (gas) and USDC to mint, and frxUSD to redeem.

### **mint-and-redeem.js**

// \============ Setup (imports, account, client) \============import 'dotenv/config';import { createWalletClient, http, encodeFunctionData, nonceManager } from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN \=  '0x4F95C5bA0C7c69FB2f9340E190cCeE890B3bd87c'; // Mint & Redeem contract address using USDC // frxUSD and USDC Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_USDC\_ADDRESS \= '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'; // USDC address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 USDC (6 decimals)const REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals) // Wallet clientconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); // \============ Helpers \============ // 1\) Approve USDC for mintasync function approveUsdcForMint() {  console.log('Approving USDC for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_USDC\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`USDC Approval Tx: ${approveTx}\`);} // 2\) Mint frxUSD with USDCasync function mintFrxusdWithUsdc() {  console.log('Minting frxUSD with USDC...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);} // 3\) Approve frxUSD for redeemasync function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} // 4\) Redeem frxUSD for USDCasync function redeemFrxusdForUsdc() {  console.log('Redeeming frxUSD for USDC...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDC\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);} // \============ Main \============async function main() {  const command \= process.argv\[2\];  switch (command) {    case 'mint-with-usdc':      console.log('Running mint with USDC...');      await approveUsdcForMint();      await mintFrxusdWithUsdc();      break;    case 'redeem-for-usdc':      console.log('Running mint with USDC...');      await approveFrxusdForRedeem();      await redeemFrxusdForUsdc();      break;    default:      console.error(        'Invalid command. Please use "mint-with-usdc" or "redeem-with-frxusd".',      );      process.exit(1);  }  console.log('Mint and redeem completed\!');} main().catch(console.error);

## **Test the script**

To test minting frxUSD with USDC, run the following command:  
node mint-and-redeem.js mint-with-usdc

To test redeeming frxUSD with USDC, run the following command:  
node mint-and-redeem.js redeem-for-usdc

Once each script runs and the mint & redeem operations are finalized, the confirmation receipts are logged in the console.

## **What's next**

* [Mint & Redeem frxUSD with USTB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/ustb)  
* [Mint & Redeem frxUSD with BUIDL](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/buidl)  
* [Mint & Redeem frxUSD with WTGXX](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/wtgxx)  
* [Mint & Redeem frxUSD with USDB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdb)  
* 

# **Mint & Redeem frxUSD with Superstate's USTB**

This guide demonstrates how to use the viem framework in a simple script that enables a user to mint and redeem frxUSD with USTB on Ethereum mainnet.

Note: Please ensure the sender and recipient addresses are onboarded to hold USTB.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token and USTB on the source chain  
   * For this guide, we will be minting and redeeming frxUSD with USTB on Ethereum mainnet. Therefore, you will need to fund your wallet with USTB and ETH on Ethereum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-mint-and-redeem-with-ustbcd frxusd-mint-and-redeem-with-ustbnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frax-mint-and-redeem-with-ustb",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node mint-and-redeem.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the mint-and-redeem.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key and associated wallet address. The script also predefines the Mint & Redeem contract address, the frxUSD address, the USTB address, the mint amount, and the redeem amount. These definitions are critical for successfully minting and redeeming frxUSD between the intended wallets.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addresses and Destination EIDconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN \=  '0x5fbAa3A3B489199338fbD85F7E3D444dc0504F33'; // Mint & Redeem contract address using USTB // frxUSD and USTB Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_USTB\_ADDRESS \= '0x43415eb6ff9db7e26a15b704e7a3edce97d31c4e'; // USTB address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 USTBconst REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD

### **2\. Set up wallet client**

The wallet client configures the appropriate network settings using viem. In this example, the script will be minting and redeeming frxUSD with USTB on Ethereum mainnet.  
// Set up a wallet client on the source chainconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,});

## **frxUSD mint & redeem process**

The following sections outline the relevant mint & redeem logic of the sample script. In this example, we are minting and redeeming frxUSD with USTB on Ethereum mainnet. Follow the steps below to perform the mint & redeem:

### **1\. Approve USTB & frxUSD**

Before minting, approve USTB for the [Mint & Redeem contract](https://docs.frax.com/frxusd/frax-zero) on Ethereum mainnet so it can pull USTB from your wallet. Before redeeming, approve frxUSD for the same contract so it can pull frxUSD. For other assets, use the appropriate contract address from the [frxUSD Mint & Redeem addresses](https://docs.frax.com/frxusd/mint-and-redeem-routes) page.  
async function approveUstbForMint() {  console.log('Approving USTB for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_USTB\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`USTB Approval Tx: ${approveTx}\`);} async function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);}

* Both approvals are now explicit: approve USTB for mint, approve frxUSD for redeem, both to ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN.

### **2\. Mint frxUSD with USTB**

After approving USTB, mint by calling the Mint & Redeem contract's deposit to receive frxUSD.  
async function mintFrxusdWithUstb() {  console.log('Minting frxUSD with USTB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);}

* Call await approveUstbForMint() first, then await mintFrxusdWithUstb().

### **3\. Redeem frxUSD with USTB**

After approving frxUSD, redeem by calling the Mint & Redeem contract's redeem to receive USTB.  
async function redeemFrxusdForUstb() {  console.log('Redeeming frxUSD for USTB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);}

* Call await approveFrxusdForRedeem() first, then await redeemFrxusdForUstb().

## **Build the script**

Create a mint-and-redeem.js in your project directory and paste the following. It groups the script setup and helper functions together at the top, followed by the main execution flow.

Note: The wallet must contain mainnet ETH (gas) and USTB to mint, and frxUSD to redeem.

### **mint-and-redeem.js**

// \============ Setup (imports, account, client) \============import 'dotenv/config';import { createWalletClient, http, encodeFunctionData, nonceManager } from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN \=  '0x5fbAa3A3B489199338fbD85F7E3D444dc0504F33'; // Mint & Redeem contract address using USTB // frxUSD and USTB Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_USTB\_ADDRESS \= '0x43415eb6ff9db7e26a15b704e7a3edce97d31c4e'; // USTB address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 USTB (6 decimals)const REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals) // Wallet clientconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); // \============ Helpers \============ // 1\) Approve USTB for mintasync function approveUstbForMint() {  console.log('Approving USTB for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_USTB\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`USTB Approval Tx: ${approveTx}\`);} // 2\) Mint frxUSD with USTBasync function mintFrxusdWithUstb() {  console.log('Minting frxUSD with USTB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);} // 3\) Approve frxUSD for redeemasync function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} // 4\) Redeem frxUSD for USTBasync function redeemFrxusdForUstb() {  console.log('Redeeming frxUSD for USTB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);} // \============ Main \============async function main() {  const command \= process.argv\[2\];  switch (command) {    case 'mint-with-ustb':      console.log('Running mint with USTB...');      await approveUstbForMint();      await mintFrxusdWithUstb();      break;    case 'redeem-for-ustb':      console.log('Running mint with USTB...');      await approveFrxusdForRedeem();      await redeemFrxusdForUstb();      break;    default:      console.error(        'Invalid command. Please use "mint-with-ustb" or "redeem-with-frxusd".',      );      process.exit(1);  }  await approveUstbForMint();  await mintFrxusdWithUstb();  // Redeem flow  await approveFrxusdForRedeem();  await redeemFrxusdForUstb();  console.log('Mint and redeem completed\!');} main().catch(console.error);

## **Test the script**

To test minting frxUSD with USTB, run the following command:  
node mint-and-redeem.js mint-with-ustb

To test redeeming frxUSD with USTB, run the following command:  
node mint-and-redeem.js redeem-for-ustb

Once the script runs and the mint & redeem operations are finalized, the confirmation receipts are logged in the console.

## **What's next**

* [Mint & Redeem frxUSD with BUIDL](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/buidl)  
* [Mint & Redeem frxUSD with WTGXX](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/wtgxx)  
* [Mint & Redeem frxUSD with USDB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdb)  
* 

# **Mint & Redeem frxUSD with Superstate's USTB**

This guide demonstrates how to use the viem framework in a simple script that enables a user to mint and redeem frxUSD with USTB on Ethereum mainnet.

Note: Please ensure the sender and recipient addresses are onboarded to hold USTB.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token and USTB on the source chain  
   * For this guide, we will be minting and redeeming frxUSD with USTB on Ethereum mainnet. Therefore, you will need to fund your wallet with USTB and ETH on Ethereum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-mint-and-redeem-with-ustbcd frxusd-mint-and-redeem-with-ustbnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frax-mint-and-redeem-with-ustb",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node mint-and-redeem.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the mint-and-redeem.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key and associated wallet address. The script also predefines the Mint & Redeem contract address, the frxUSD address, the USTB address, the mint amount, and the redeem amount. These definitions are critical for successfully minting and redeeming frxUSD between the intended wallets.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addresses and Destination EIDconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN \=  '0x5fbAa3A3B489199338fbD85F7E3D444dc0504F33'; // Mint & Redeem contract address using USTB // frxUSD and USTB Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_USTB\_ADDRESS \= '0x43415eb6ff9db7e26a15b704e7a3edce97d31c4e'; // USTB address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 USTBconst REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD

### **2\. Set up wallet client**

The wallet client configures the appropriate network settings using viem. In this example, the script will be minting and redeeming frxUSD with USTB on Ethereum mainnet.  
// Set up a wallet client on the source chainconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,});

## **frxUSD mint & redeem process**

The following sections outline the relevant mint & redeem logic of the sample script. In this example, we are minting and redeeming frxUSD with USTB on Ethereum mainnet. Follow the steps below to perform the mint & redeem:

### **1\. Approve USTB & frxUSD**

Before minting, approve USTB for the [Mint & Redeem contract](https://docs.frax.com/frxusd/frax-zero) on Ethereum mainnet so it can pull USTB from your wallet. Before redeeming, approve frxUSD for the same contract so it can pull frxUSD. For other assets, use the appropriate contract address from the [frxUSD Mint & Redeem addresses](https://docs.frax.com/frxusd/mint-and-redeem-routes) page.  
async function approveUstbForMint() {  console.log('Approving USTB for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_USTB\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`USTB Approval Tx: ${approveTx}\`);} async function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);}

* Both approvals are now explicit: approve USTB for mint, approve frxUSD for redeem, both to ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN.

### **2\. Mint frxUSD with USTB**

After approving USTB, mint by calling the Mint & Redeem contract's deposit to receive frxUSD.  
async function mintFrxusdWithUstb() {  console.log('Minting frxUSD with USTB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);}

* Call await approveUstbForMint() first, then await mintFrxusdWithUstb().

### **3\. Redeem frxUSD with USTB**

After approving frxUSD, redeem by calling the Mint & Redeem contract's redeem to receive USTB.  
async function redeemFrxusdForUstb() {  console.log('Redeeming frxUSD for USTB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);}

* Call await approveFrxusdForRedeem() first, then await redeemFrxusdForUstb().

## **Build the script**

Create a mint-and-redeem.js in your project directory and paste the following. It groups the script setup and helper functions together at the top, followed by the main execution flow.

Note: The wallet must contain mainnet ETH (gas) and USTB to mint, and frxUSD to redeem.

### **mint-and-redeem.js**

// \============ Setup (imports, account, client) \============import 'dotenv/config';import { createWalletClient, http, encodeFunctionData, nonceManager } from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN \=  '0x5fbAa3A3B489199338fbD85F7E3D444dc0504F33'; // Mint & Redeem contract address using USTB // frxUSD and USTB Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_USTB\_ADDRESS \= '0x43415eb6ff9db7e26a15b704e7a3edce97d31c4e'; // USTB address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 USTB (6 decimals)const REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals) // Wallet clientconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); // \============ Helpers \============ // 1\) Approve USTB for mintasync function approveUstbForMint() {  console.log('Approving USTB for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_USTB\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`USTB Approval Tx: ${approveTx}\`);} // 2\) Mint frxUSD with USTBasync function mintFrxusdWithUstb() {  console.log('Minting frxUSD with USTB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);} // 3\) Approve frxUSD for redeemasync function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} // 4\) Redeem frxUSD for USTBasync function redeemFrxusdForUstb() {  console.log('Redeeming frxUSD for USTB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USTB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);} // \============ Main \============async function main() {  const command \= process.argv\[2\];  switch (command) {    case 'mint-with-ustb':      console.log('Running mint with USTB...');      await approveUstbForMint();      await mintFrxusdWithUstb();      break;    case 'redeem-for-ustb':      console.log('Running mint with USTB...');      await approveFrxusdForRedeem();      await redeemFrxusdForUstb();      break;    default:      console.error(        'Invalid command. Please use "mint-with-ustb" or "redeem-with-frxusd".',      );      process.exit(1);  }  await approveUstbForMint();  await mintFrxusdWithUstb();  // Redeem flow  await approveFrxusdForRedeem();  await redeemFrxusdForUstb();  console.log('Mint and redeem completed\!');} main().catch(console.error);

## **Test the script**

To test minting frxUSD with USTB, run the following command:  
node mint-and-redeem.js mint-with-ustb

To test redeeming frxUSD with USTB, run the following command:  
node mint-and-redeem.js redeem-for-ustb

Once the script runs and the mint & redeem operations are finalized, the confirmation receipts are logged in the console.

## **What's next**

* [Mint & Redeem frxUSD with BUIDL](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/buidl)  
* [Mint & Redeem frxUSD with WTGXX](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/wtgxx)  
* [Mint & Redeem frxUSD with USDB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdb)  
* 

# **Mint & Redeem frxUSD with Blackrock's BUIDL**

This guide demonstrates how to use the viem framework in a simple script that enables a user to mint and redeem frxUSD with BUIDL on Ethereum mainnet.

Note: Please ensure the sender and recipient addresses are onboarded to hold BUIDL.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token and BUIDL on the source chain  
   * For this guide, we will be minting and redeeming frxUSD with BUIDL on Ethereum mainnet. Therefore, you will need to fund your wallet with BUIDL and ETH on Ethereum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-mint-and-redeem-with-buidlcd frxusd-mint-and-redeem-with-buidlnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frax-mint-and-redeem-with-buidl",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node mint-and-redeem.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the mint-and-redeem.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key and associated wallet address. The script also predefines the Mint & Redeem contract address, the frxUSD address, the BUIDL address, the mint amount, and the redeem amount. These definitions are critical for successfully minting and redeeming frxUSD between the intended wallets.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addresses and Destination EIDconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN \=  '0xe827abf9f462ac4f147753d86bc5f91e186e4e9c'; // Mint & Redeem contract address using BUIDL // frxUSD and BUIDL Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_BUIDL\_ADDRESS \= '0x7712c34205737192402172409a8f7ccef8aa2aec'; // BUIDL address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 BUIDLconst REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD

### **2\. Set up wallet client**

The wallet client configures the appropriate network settings using viem. In this example, the script will be minting and redeeming frxUSD with BUIDL on Ethereum mainnet.  
// Set up a wallet client on the source chainconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,});

## **frxUSD mint & redeem process**

The following sections outline the relevant mint & redeem logic of the sample script. In this example, we are minting and redeeming frxUSD with BUIDL on Ethereum mainnet. Follow the steps below to perform the mint & redeem:

### **1\. Approve BUIDL & frxUSD**

Before minting, approve BUIDL for the [Mint & Redeem contract](https://docs.frax.com/frxusd/frax-zero) on Ethereum mainnet so it can pull BUIDL from your wallet. Before redeeming, approve frxUSD for the same contract so it can pull frxUSD. For other assets, use the appropriate contract address from the [frxUSD Mint & Redeem addresses](https://docs.frax.com/frxusd/mint-and-redeem-routes) page.  
async function approveBuidlForMint() {  console.log('Approving BUIDL for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_BUIDL\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`BUIDL Approval Tx: ${approveTx}\`);} async function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);}

* Both approvals are now explicit: approve BUIDL for mint, approve frxUSD for redeem, both to ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN.

### **2\. Mint frxUSD with BUIDL**

After approving BUIDL, mint by calling the Mint & Redeem contract's deposit to receive frxUSD.  
async function mintFrxusdWithBuidl() {  console.log('Minting frxUSD with BUIDL...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);}

* Call await approveBuidlForMint() first, then await mintFrxusdWithBuidl().

### **3\. Redeem frxUSD with BUIDL**

After approving frxUSD, redeem by calling the Mint & Redeem contract's redeem to receive BUIDL.  
async function redeemFrxusdForBuidl() {  console.log('Redeeming frxUSD for BUIDL...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);}

* Call await approveFrxusdForRedeem() first, then await redeemFrxusdForBuidl().

## **Build the script**

Create a mint-and-redeem.js in your project directory and paste the following. It groups the script setup and helper functions together at the top, followed by the main execution flow.

Note: The wallet must contain mainnet ETH (gas) and BUIDL to mint, and frxUSD to redeem.

### **mint-and-redeem.js**

// \============ Setup (imports, account, client) \============import 'dotenv/config';import { createWalletClient, http, encodeFunctionData, nonceManager } from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN \=  '0xe827abf9f462ac4f147753d86bc5f91e186e4e9c'; // Mint & Redeem contract address using BUIDL // frxUSD and BUIDL Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_BUIDL\_ADDRESS \= '0x7712c34205737192402172409a8f7ccef8aa2aec'; // BUIDL address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 BUIDL (6 decimals)const REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals) // Wallet clientconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); // \============ Helpers \============ // 1\) Approve BUIDL for mintasync function approveBuidlForMint() {  console.log('Approving BUIDL for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_BUIDL\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`BUIDL Approval Tx: ${approveTx}\`);} // 2\) Mint frxUSD with BUIDLasync function mintFrxusdWithBuidl() {  console.log('Minting frxUSD with BUIDL...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);} // 3\) Approve frxUSD for redeemasync function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} // 4\) Redeem frxUSD for BUIDLasync function redeemFrxusdForBuidl() {  console.log('Redeeming frxUSD for BUIDL...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_BUIDL\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);} // \============ Main \============async function main() {  const command \= process.argv\[2\];  switch (command) {    case 'mint-with-buidl':      console.log('Running mint with BUIDL...');      await approveBuidlForMint();      await mintFrxusdWithBuidl();      break;    case 'redeem-for-buidl':      console.log('Running mint with BUIDL...');      await approveFrxusdForRedeem();      await redeemFrxusdForBuidl();      break;    default:      console.error(        'Invalid command. Please use "mint-with-buidl" or "redeem-for-buidl".',      );      process.exit(1);  }  console.log('Mint and redeem completed\!');} main().catch(console.error);

## **Test the script**

To test minting frxUSD with BUIDL, run the following command:  
node mint-and-redeem.js mint-with-buidl

To test redeeming frxUSD with BUIDL, run the following command:  
node mint-and-redeem.js redeem-for-buidl

Once the script runs and the mint & redeem operations are finalized, the confirmation receipts are logged in the console.

## **What's next**

* [Mint & Redeem frxUSD with WTGXX](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/wtgxx)  
* [Mint & Redeem frxUSD with USDB](https://docs.frax.com/frxusd/mint-and-redeem-quickstarts/usdb)  
* 

# **Mint & Redeem frxUSD with WisdomTree's WTGXX**

This guide demonstrates how to use the viem framework in a simple script that enables a user to mint and redeem frxUSD with WTGXX on Ethereum mainnet.

Note: Please ensure the sender and recipient addresses are onboarded to hold WTGXX.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token and WTGXX on the source chain  
   * For this guide, we will be minting and redeeming frxUSD with WTGXX on Ethereum mainnet. Therefore, you will need to fund your wallet with WTGXX and ETH on Ethereum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-mint-and-redeem-with-wtgxxcd frxusd-mint-and-redeem-with-wtgxxnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frax-mint-and-redeem-with-wtgxx",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node mint-and-redeem.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the mint-and-redeem.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key and associated wallet address. The script also predefines the Mint & Redeem contract address, the frxUSD address, the WTGXX address, the mint amount, and the redeem amount. These definitions are critical for successfully minting and redeeming frxUSD between the intended wallets.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addresses and Destination EIDconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN \=  '0x860Cc723935FC9A15fF8b1A94237a711DFeF7857'; // Mint & Redeem contract address using WTGXX // frxUSD and WTGXX Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_WTGXX\_ADDRESS \= '0x1fecf3d9d4fee7f2c02917a66028a48c6706c179'; // WTGXX address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 WTGXXconst REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD

### **2\. Set up wallet client**

The wallet client configures the appropriate network settings using viem. In this example, the script will be minting and redeeming frxUSD with WTGXX on Ethereum mainnet.  
// Set up a wallet client on the source chainconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,});

## **frxUSD mint & redeem process**

The following sections outline the relevant mint & redeem logic of the sample script. In this example, we are minting and redeeming frxUSD with WTGXX on Ethereum mainnet. Follow the steps below to perform the mint & redeem:

### **1\. Approve WTGXX & frxUSD**

Before minting, approve WTGXX for the [Mint & Redeem contract](https://docs.frax.com/frxusd/frax-zero) on Ethereum mainnet so it can pull WTGXX from your wallet. Before redeeming, approve frxUSD for the same contract so it can pull frxUSD. For other assets, use the appropriate contract address from the [frxUSD Mint & Redeem addresses](https://docs.frax.com/frxusd/mint-and-redeem-routes) page.  
async function approveWtgxxForMint() {  console.log('Approving WTGXX for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_WTGXX\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`WTGXX Approval Tx: ${approveTx}\`);} async function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);}

* Both approvals are now explicit: approve WTGXX for mint, approve frxUSD for redeem, both to ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN.

### **2\. Mint frxUSD with WTGXX**

After approving WTGXX, mint by calling the Mint & Redeem contract's deposit to receive frxUSD.  
async function mintFrxusdWithWtgxx() {  console.log('Minting frxUSD with WTGXX...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);}

* Call await approveWtgxxForMint() first, then await mintFrxusdWithWtgxx().

### **3\. Redeem frxUSD with WTGXX**

After approving frxUSD, redeem by calling the Mint & Redeem contract's redeem to receive WTGXX.  
async function redeemFrxusdForWtgxx() {  console.log('Redeeming frxUSD for WTGXX...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);}

* Call await approveFrxusdForRedeem() first, then await redeemFrxusdForWtgxx().

## **Build the script**

Create a mint-and-redeem.js in your project directory and paste the following. It groups the script setup and helper functions together at the top, followed by the main execution flow.

Note: The wallet must contain mainnet ETH (gas) and WTGXX to mint, and frxUSD to redeem.

### **mint-and-redeem.js**

// \============ Setup (imports, account, client) \============import 'dotenv/config';import { createWalletClient, http, encodeFunctionData, nonceManager } from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN \=  '0x860Cc723935FC9A15fF8b1A94237a711DFeF7857'; // Mint & Redeem contract address using WTGXX // frxUSD and WTGXX Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_WTGXX\_ADDRESS \= '0x1fecf3d9d4fee7f2c02917a66028a48c6706c179'; // WTGXX address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 WTGXX (18 decimals)const REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals) // Wallet clientconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); // \============ Helpers \============ // 1\) Approve WTGXX for mintasync function approveWtgxxForMint() {  console.log('Approving WTGXX for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_WTGXX\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`WTGXX Approval Tx: ${approveTx}\`);} // 2\) Mint frxUSD with WTGXXasync function mintFrxusdWithWtgxx() {  console.log('Minting frxUSD with WTGXX...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);} // 3\) Approve frxUSD for redeemasync function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} // 4\) Redeem frxUSD for WTGXXasync function redeemFrxusdForWtgxx() {  console.log('Redeeming frxUSD for WTGXX...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_WTGXX\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);} // \============ Main \============async function main() {  const command \= process.argv\[2\];  switch (command) {    case 'mint-with-wtgxx':      console.log('Running mint with WTGXX...');      await approveWtgxxForMint();      await mintFrxusdWithWtgxx();      break;    case 'redeem-for-wtgxx':      console.log('Running redeem with WTGXX...');      await approveFrxusdForRedeem();      await redeemFrxusdForWtgxx();      break;    default:      console.error(        'Invalid command. Please use "mint-with-wtgxx" or "redeem-for-wtgxx".',      );      process.exit(1);  }  console.log('Mint and redeem completed\!');} main().catch(console.error);

## **Test the script**

To test minting frxUSD with WTGXX, run the following command:  
node mint-and-redeem.js mint-with-wtgxx

To test redeeming frxUSD with WTGXX, run the following command:  
node mint-and-redeem.js redeem-for-wtgxx

Once the script runs and the mint & redeem operations are finalized, the confirmation receipts are logged in the console.

## **What's next**

* [Mint & Redeem frxUSD Cross-Chain](https://docs.frax.com/frxusd/cross-chain-mint-and-redeem-quickstart)  
* 

# **Mint & Redeem frxUSD with Bridge.xyz's USDB**

This guide demonstrates how to use the viem framework in a simple script that enables a user to mint and redeem frxUSD with USDB on Ethereum mainnet.

## **Prerequisites**

Before you start building the sample app to perform a frxUSD transfer, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token and USDB on the source chain  
   * For this guide, we will be minting and redeeming frxUSD with USDB on Ethereum mainnet. Therefore, you will need to fund your wallet with USDB and ETH on Ethereum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-mint-and-redeem-with-usdbcd frxusd-mint-and-redeem-with-usdbnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frax-mint-and-redeem-with-usdb",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node mint-and-redeem.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the mint-and-redeem.js script, including defining keys and addresses, and configuring the wallet client for interacting with the source and destination chains.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key and associated wallet address. The script also predefines the Mint & Redeem contract address, the frxUSD address, the USDB address, the mint amount, and the redeem amount. These definitions are critical for successfully minting and redeeming frxUSD between the intended wallets.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addresses and Destination EIDconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN \=  '0xFE2Ea8dE262d956e852F12DE108fda57171a0a29'; // Mint & Redeem contract address using USDB // frxUSD and USDB Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_USDB\_ADDRESS \= '0xeac4269c9a01190b1400c4dc728864e61895fdf3'; // USDB address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 USDBconst REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD

### **2\. Set up wallet client**

The wallet client configures the appropriate network settings using viem. In this example, the script will be minting and redeeming frxUSD with USDB on Ethereum mainnet.  
// Set up a wallet client on the source chainconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,});

## **frxUSD mint & redeem process**

The following sections outline the relevant mint & redeem logic of the sample script. In this example, we are minting and redeeming frxUSD with USDB on Ethereum mainnet. Follow the steps below to perform the mint & redeem:

### **1\. Approve USDB & frxUSD**

Before minting, approve USDB for the [Mint & Redeem contract](https://docs.frax.com/frxusd/frax-zero) on Ethereum mainnet so it can pull USDB from your wallet. Before redeeming, approve frxUSD for the same contract so it can pull frxUSD. For other assets, use the appropriate contract address from the [frxUSD Mint & Redeem addresses](https://docs.frax.com/frxusd/mint-and-redeem-routes) page.  
async function approveUsdbForMint() {  console.log('Approving USDB for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_USDB\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`USDB Approval Tx: ${approveTx}\`);} async function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);}

* Both approvals are now explicit: approve USDB for mint, approve frxUSD for redeem, both to ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN.

### **2\. Mint frxUSD with USDB**

After approving USDB, mint by calling the Mint & Redeem contract's deposit to receive frxUSD.  
async function mintFrxusdWithUsdb() {  console.log('Minting frxUSD with USDB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);}

* Call await approveUsdbForMint() first, then await mintFrxusdWithUsdb().

### **3\. Redeem frxUSD with USDB**

After approving frxUSD, redeem by calling the Mint & Redeem contract's redeem to receive USDB.  
async function redeemFrxusdForUsdb() {  console.log('Redeeming frxUSD for USDB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);}

* Call await approveFrxusdForRedeem() first, then await redeemFrxusdForUsdb().

## **Build the script**

Create a mint-and-redeem.js in your project directory and paste the following. It groups the script setup and helper functions together at the top, followed by the main execution flow.

Note: The wallet must contain mainnet ETH (gas) and USDB to mint, and frxUSD to redeem.

### **mint-and-redeem.js**

// \============ Setup (imports, account, client) \============import 'dotenv/config';import { createWalletClient, http, encodeFunctionData, nonceManager } from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // Mint & Redeem Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN \=  '0xFE2Ea8dE262d956e852F12DE108fda57171a0a29'; // Mint & Redeem contract address using USDB // frxUSD and USDB Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29'; // frxUSD address on Ethereum mainnetconst ETHEREUM\_MAINNET\_USDB\_ADDRESS \= '0xeac4269c9a01190b1400c4dc728864e61895fdf3'; // USDB address on Ethereum mainnet // Mint & Redeem Parametersconst MINT\_AMOUNT \= 10\_000\_000n; // 10 USDB (6 decimals)const REDEEM\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals) // Wallet clientconst ethereumClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); // \============ Helpers \============ // 1\) Approve USDB for mintasync function approveUsdbForMint() {  console.log('Approving USDB for mint...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_USDB\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN, MINT\_AMOUNT\],    }),  });  console.log(\`USDB Approval Tx: ${approveTx}\`);} // 2\) Mint frxUSD with USDBasync function mintFrxusdWithUsdb() {  console.log('Minting frxUSD with USDB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[MINT\_AMOUNT, account.address\],    }),  });  console.log(\`Mint Tx: ${txHash}\`);} // 3\) Approve frxUSD for redeemasync function approveFrxusdForRedeem() {  console.log('Approving frxUSD for redeem...');  const approveTx \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN, REDEEM\_AMOUNT\],    }),  });  console.log(\`frxUSD Approval Tx: ${approveTx}\`);} // 4\) Redeem frxUSD for USDBasync function redeemFrxusdForUsdb() {  console.log('Redeeming frxUSD for USDB...');  const txHash \= await ethereumClient.sendTransaction({    to: ETHEREUM\_MAINNET\_FRXUSD\_MINT\_AND\_REDEEM\_USDB\_CUSTODIAN,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[REDEEM\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Redeem Tx: ${txHash}\`);} // \============ Main \============async function main() {  const command \= process.argv\[2\];  switch (command) {    case 'mint-with-usdb':      console.log('Running mint with USDB...');      await approveUsdbForMint();      await mintFrxusdWithUsdb();      break;    case 'redeem-for-usdb':      console.log('Running redeem with USDB...');      await approveFrxusdForRedeem();      await redeemFrxusdForUsdb();      break;    default:      console.error('Invalid command. Please use "mint-with-usdb" or "redeem-for-usdb".');      process.exit(1);  }  console.log('Mint and redeem completed\!');} main().catch(console.error);

## **Test the script**

To test minting frxUSD with USDB, run the following command:  
node mint-and-redeem.js mint-with-usdb

To test redeeming frxUSD with USDB, run the following command:  
node mint-and-redeem.js redeem-for-usdb

Once the script runs and the mint & redeem operations are finalized, the confirmation receipts are logged in the console.

## **What's next**

* [Mint & Redeem frxUSD Cross-Chain](https://docs.frax.com/frxusd/cross-chain-mint-and-redeem-quickstart)  
* 

# **Stake & Unstake frxUSD Overview**

Stake frxUSD for sfrxUSD (Frax's savings product) to earn daily interest from tokenized institutional U.S. treasury fund reserves, Superstate's USCC, Ethena's USDe, and Sky's (formerly Maker) sUSDS. [Learn more](https://docs.frax.com/protocol/assets/frxusd/sfrxusd)

## **What is sfrxUSD?**

Staked Frax USD (sfrxUSD) is Frax's yielding stablecoin implemented as an ERC4626 token. When you stake your frxUSD, you receive sfrxUSD tokens that automatically accrue yield over time. sfrxUSD is fully redeemable for frxUSD at an increasing rate proportional to the yield mechanism, with no unstaking fees or price impact.

### **Key Features**

* No Lock-up Period: Stake and unstake at any time  
* No Fees: Zero staking or unstaking fees  
* Automatic Yield: Earn yield without manual intervention  
* Cross-Chain Support: Available on 20+ blockchain networks  
* ERC4626 Standard: Compatible with DeFi protocols and wallets

## **How Yield Works**

sfrxUSD uses Frax's Benchmark Yield Strategy (BYS) to automatically allocate your staked frxUSD to the highest-yielding venue based on current market conditions:

### **Yield Sources**

1. Carry-Trade Strategies  
   * Ethena (USDe)  
   * Superstate (USCC)  
2. DeFi AMO Strategies  
   * Aave  
   * Curve Finance  
   * Convex Finance  
   * Compound Finance  
3. Real-World Assets (RWA)  
   * Blackrock Treasury Bills  
   * FinresPBC Treasury Bills

The system automatically switches between these strategies to ensure you always earn the highest risk-adjusted yield available in the market.

## **Supported Networks**

sfrxUSD staking is available on 20+ blockchain networks, including:

* Ethereum (mainnet)  
* Fraxtal (Frax's L2)  
* Arbitrum, Optimism, Base (L2s)  
* Polygon, Avalanche, BSC (L1s)  
* And many more...

For a complete list of supported networks and contract addresses, see [Supported Networks and EIDs](https://docs.frax.com/frxusd/stake-and-unstake-supported-networks).

## **Getting Started**

Choose the guide that matches your target network:

### **Ethereum Mainnet**

* Lockbox Method: Uses lockbox contracts  
* Guide: [Stake & Unstake frxUSD on Ethereum](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-ethereum)

### **Fraxtal**

* Native Support: Direct staking contracts  
* Guide: [Stake & Unstake frxUSD on Fraxtal](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-fraxtal)

### **Other EVM Chains**

* Standard Method: Works on most EVM chains  
* Guide: [Stake & Unstake frxUSD on EVM chains](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-evm-chains)

## **Next Steps**

Ready to start earning yield? Choose your network and follow the appropriate quickstart guide:

* [Supported Networks and EIDs](https://docs.frax.com/frxusd/stake-and-unstake-supported-networks)  
* [Stake & Unstake on Ethereum](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-ethereum)  
* [Stake & Unstake on EVM Chains](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-evm-chains)  
* [Stake & Unstake on Fraxtal](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-fraxtal)  
* 

# **Stake & Unstake Supported Networks and EIDs**

### **sfrxUSD Token Addresses**

The table below provides a comprehensive list of all blockchain networks sfrxUSD is live on:

| Mainnet | Address |
| ----- | ----- |
| Ethereum | [0xcf62F905562626CfcDD2261162a51fd02Fc9c5b6](https://etherscan.io/address/0xcf62F905562626CfcDD2261162a51fd02Fc9c5b6) |
| Fraxtal | [0xfc00000000000000000000000000000000000008](https://fraxscan.com/address/0xfc00000000000000000000000000000000000008) |
| Abstract | [0x9F87fbb47C33Cd0614E43500b9511018116F79eE](https://explorer.mainnet.abs.xyz/address/0x9F87fbb47C33Cd0614E43500b9511018116F79eE) |
| Arbitrum | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://arbiscan.io/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Avalanche | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://snowtrace.io/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Base | [0x91A3f8a8d7a881fBDfcfEcd7A2Dc92a46DCfa14e](https://basescan.org/address/0x91A3f8a8d7a881fBDfcfEcd7A2Dc92a46DCfa14e) |
| Berachain | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://berascan.com/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| BSC | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://bscscan.com/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Ink | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://explorer.inkonchain.com/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Katana | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://katanascan.com/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Linea | [0x592a48c0FB9c7f8BF1701cB0136b90DEa2A5B7B6](https://lineascan.build/address/0x592a48c0FB9c7f8BF1701cB0136b90DEa2A5B7B6) |
| Mode | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://explorer.mode.network/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Optimism | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://optimistic.etherscan.io/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Plume | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://explorer.plume.org/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Polygon | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://polygonscan.com/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Polygon zkEVM | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://zkevm.polygonscan.com/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Sei | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://seitrace.com/token/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Solana | [DUvWQMyASSkLNJFwsMDA4kwxEvmfaqpPGrvUVKtitX45](https://solscan.io/account/DUvWQMyASSkLNJFwsMDA4kwxEvmfaqpPGrvUVKtitX45) |
| Sonic | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://sonicscan.org/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| Unichain | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://unichain.blockscout.com/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| XLayer | [0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0](https://www.oklink.com/x-layer/address/0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0) |
| zkSync | [0x9F87fbb47C33Cd0614E43500b9511018116F79eE](https://explorer.zksync.io/address/0x9F87fbb47C33Cd0614E43500b9511018116F79eE) |

### **Stake & Unstake Hop Contracts**

frxUSD stake and unstake operations are available cross-chain between the following networks using the Hop method. Follow our [Stake & Unstake frxUSD cross-chain](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-cross-chain) guide to get started.

| Mainnet | EID | Hop Address |
| ----- | ----- | ----- |
| Ethereum | 30101 | [0x99b5587ab54a49e3f827d10175caf69c0187bfa8](https://etherscan.io/address/0x99b5587ab54a49e3f827d10175caf69c0187bfa8) |
| Abstract | 30324 | [0xa05e9f9b97c963b5651ed6a50fae46625a8c400b](https://explorer.mainnet.abs.xyz/address/0xa05e9f9b97c963b5651ed6a50fae46625a8c400b) |
| Arbitrum | 30110 | [0xa46A266dCBf199a71532c76967e200994C5A0D6d](https://arbiscan.io/address/0xa46A266dCBf199a71532c76967e200994C5A0D6d) |
| Aurora | 30211 | [0x8ebb34b1880b2ea5e458082590b3a2c9ea7c41a2](https://aurorascan.dev/address/0x8ebb34b1880b2ea5e458082590b3a2c9ea7c41a2) |
| Avalanche | 30106 | [0x452420df4AC1e3db5429b5FD629f3047482C543C](https://snowtrace.io/address/0x452420df4AC1e3db5429b5FD629f3047482C543C) |
| Base | 30184 | [0x73382eb28F35d80Df8C3fe04A3EED71b1aFce5dE](https://basescan.org/address/0x73382eb28F35d80Df8C3fe04A3EED71b1aFce5dE) |
| Berachain | 30362 | [0x983aF86c94Fe3963989c22CeeEb6eA8Eac32D263](https://berascan.com/address/0x983aF86c94Fe3963989c22CeeEb6eA8Eac32D263) |
| BSC | 30102 | [0xdee45510b42Cb0678C8A61D043C698aF66b0d852](https://bscscan.com/address/0xdee45510b42Cb0678C8A61D043C698aF66b0d852) |
| Ink | 30339 | [0x452420df4AC1e3db5429b5FD629f3047482C543C](https://explorer.inkonchain.com/address/0x452420df4AC1e3db5429b5FD629f3047482C543C) |
| Katana | 30375 | [0xf6f45ccb5e85d1400067ee66f9e168f83e86124e](https://katanascan.com/address/0xf6f45ccb5e85d1400067ee66f9e168f83e86124e) |
| Linea | 30183 | [0xa71f2204EDDB8d84F411A0C712687FAe5002e7Fb](https://lineascan.build/address/0xa71f2204EDDB8d84F411A0C712687FAe5002e7Fb) |
| Mode | 30260 | [0x7360575f6f8F91b38dD078241b0Df508f5fBfDf9](https://explorer.mode.network/address/0x7360575f6f8F91b38dD078241b0Df508f5fBfDf9) |
| Optimism | 30111 | [0x7a07D606c87b7251c2953A30Fa445d8c5F856C7A](https://optimistic.etherscan.io/address/0x7a07D606c87b7251c2953A30Fa445d8c5F856C7A) |
| Plume | 30370 | [0xa71f2204EDDB8d84F411A0C712687FAe5002e7Fb](https://explorer.plume.org/address/0xa71f2204EDDB8d84F411A0C712687FAe5002e7Fb) |
| Polygon | 30109 | [0x5658e82E330e094627D9b362ed0E137eA06673C4](https://polygonscan.com/address/0x5658e82E330e094627D9b362ed0E137eA06673C4) |
| Polygon zkEVM | 30158 | [0x111ddab65Af5fF96b674400246699ED40F550De1](https://zkevm.polygonscan.com/address/0x111ddab65Af5fF96b674400246699ED40F550De1) |
| Scroll | 30214 | [0x91ddb0e0c36b901c6bf53b9eb5aca0eb1465f558](https://scrollscan.com/address/0x91ddb0e0c36b901c6bf53b9eb5aca0eb1465f558) |
| Sei | 30280 | [0x0255a172d0a060F2bEab3e7c12334dD73cCC26ba](https://seitrace.com/token/0x0255a172d0a060F2bEab3e7c12334dD73cCC26ba) |
| Sonic | 30332 | [0xf6115Bb9b6A4b3660dA409cB7afF1fb773efaD0b](https://sonicscan.org/address/0xf6115Bb9b6A4b3660dA409cB7afF1fb773efaD0b) |
| Unichain | 30320 | [0x983aF86c94Fe3963989c22CeeEb6eA8Eac32D263](https://unichain.blockscout.com/address/0x983aF86c94Fe3963989c22CeeEb6eA8Eac32D263) |
| XLayer | 30274 | [0x45c6852A5188Ce1905567EA83454329bd4982007](https://www.oklink.com/x-layer/address/0x45c6852A5188Ce1905567EA83454329bd4982007) |
| zkSync | 30165 | [0xa05e9f9b97c963b5651ed6a50fae46625a8c400b](https://explorer.zksync.io/address/0xa05e9f9b97c963b5651ed6a50fae46625a8c400b) |
| Worldchain | 30319 | [0x111ddab65Af5fF96b674400246699ED40F550De1](https://worldscan.org/address/0x111ddab65Af5fF96b674400246699ED40F550De1) |
| Unichain | 30320 | [0x983aF86c94Fe3963989c22CeeEb6eA8Eac32D263](https://uniscan.xyz/address/0x983aF86c94Fe3963989c22CeeEb6eA8Eac32D263) |
| Plume | 30370 | [0xa71f2204EDDB8d84F411A0C712687FAe5002e7Fb](https://explorer.plume.org/address/0xa71f2204EDDB8d84F411A0C712687FAe5002e7Fb) |
| Scroll | 30214 | [0x91DDB0E0C36B901C6BF53B9Eb5ACa0Eb1465F558](https://scrollscan.com/address/0x91ddb0e0c36b901c6bf53b9eb5aca0eb1465f558) |
| Aurora | 30211 | [0x8EbB34b1880B2EA5e458082590B3A2c9Ea7C41A2](https://explorer.aurora.dev/address/0x8EbB34b1880B2EA5e458082590B3A2c9Ea7C41A2). |
| Katana | 30375 | [0xF6f45CCB5E85D1400067ee66F9e168f83e86124E](https://explorer.katanarpc.com/address/0xF6f45CCB5E85D1400067ee66F9e168f83e86124E) |
| Hyperliquid | 30367 | [0xb85A8FDa7F5e52E32fa5582847CFfFee9456a5Dc](https://hyperevmscan.io/address/0xb85a8fda7f5e52e32fa5582847cfffee9456a5dc) |
| Stable | 30396 | [0xb85a8fda7f5e52e32fa5582847cfffee9456a5dc](https://stablescan.xyz/address/0xb85a8fda7f5e52e32fa5582847cfffee9456a5dc) |

Note: To stake and unstake frxUSD on Ethereum mainnet, you also need to use the Ethereum Lockbox addresses:

| Mainnet | frxUSD Lockbox Address | sfrxUSD Lockbox Address |
| ----- | ----- | ----- |
| Ethereum | [0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0](https://etherscan.io/address/0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0) | [0x7311cea93ccf5f4f7b789ee31eba5d9b9290e126](https://etherscan.io/address/0x7311cea93ccf5f4f7b789ee31eba5d9b9290e126) |

Follow our [Stake & Unstake frxUSD on Ethereum](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-ethereum) guide to get started.

### **Stake & Unstake Fraxtal Contracts**

To stake and unstake frxUSD on Fraxtal, use the following contracts. Follow our [Stake & Unstake frxUSD on Fraxtal](https://docs.frax.com/frxusd/stake-and-unstake-quickstart) guide to get started.

| Mainnet | frxUSD Stake & Unstake Contract |
| ----- | ----- |
| Fraxtal | [0xBFc4D34Db83553725eC6c768da71D2D9c1456B55](https://fraxscan.com/address/0xBFc4D34Db83553725eC6c768da71D2D9c1456B55)  |

# **Stake & Unstake frxUSD on EVM chains**

This guide shows how to use the viem framework to stake frxUSD for sfrxUSD and unstake sfrxUSD back to frxUSD on all EVM chains (excluding Ethereum mainnet and Fraxtal mainnet). We'll use Arbitrum mainnet as our example.

To see a list of all supported networks, see the [Stake & Unstake Supported Networks and EIDs](https://docs.frax.com/frxusd/stake-and-unstake-supported-networks) page.

Note: The methods for staking and unstaking frxUSD on Ethereum mainnet and Fraxtal mainnet are different from the method for staking and unstaking frxUSD on all other EVM chains. See the [Stake & Unstake frxUSD on Fraxtal](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-fraxtal) guide or the [Stake & Unstake frxUSD on Ethereum](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-ethereum) guide for more information.

## **Prerequisites**

Before you start building the sample app to perform frxUSD staking operations, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Arbitrum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token on the chain you want to stake from  
   * For this guide, we will be staking and unstaking frxUSD on Arbitrum mainnet. Therefore, you will need to fund your wallet with ETH on Arbitrum mainnet.  
4. Fund your wallet with frxUSD and sfrxUSD on the chain you want to stake and unstake from  
   * For this guide, we will be staking and unstaking frxUSD on Arbitrum mainnet. Therefore, you will need to fund your wallet with frxUSD and sfrxUSD on Arbitrum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-staking-arbitrumcd frxusd-staking-arbitrumnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frxusd-staking-arbitrum",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node stake-and-unstake.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the staking script, including defining contract addresses for Arbitrum mainnet and configuring the wallet client.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key for PRIVATE\_KEY and associated wallet address for DESTINATION\_ADDRESS.

The script also predefines the Hop contract address, the frxUSD contract address, the sfrxUSD contract address, the staking amount, and the unstaking amount. These definitions are critical for successfully staking and unstaking frxUSD.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // FILL IN THE FOLLOWING VARIABLEconst DESTINATION\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Recipient addressconst DESTINATION\_ADDRESS\_BYTES32 \= \`0x000000000000000000000000${DESTINATION\_ADDRESS.slice(2)}\`; // Convert to bytes32 format // Hop Contract Addressconst ARBITRUM\_MAINNET\_HOP\_ADDRESS \= '0xa46A266dCBf199a71532c76967e200994C5A0D6d'; // frxUSD and sfrxUSD Contract Addressesconst ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS \= '0x80Eede496655FB9047dd39d9f418d5483ED600df';const ARBITRUM\_MAINNET\_SFRXUSD\_ADDRESS \= '0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0'; // Staking Parametersconst STAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals)const UNSTAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 sfrxUSD (18 decimals)

### **2\. Set up clients**

The script creates a wallet client and a public client for Arbitrum network:  
// Set up wallet clientconst arbitrumWalletClient \= createWalletClient({  chain: arbitrum,  transport: http(),  account,}); // Set up public clientconst arbitrumPublicClient \= createPublicClient({  chain: arbitrum,  transport: http(),});

## **frxUSD staking and unstaking process**

The following sections outline the relevant staking and unstaking logic of the sample script. In this example, we are first staking 1 frxUSD on Arbitrum mainnet to receive 1 sfrxUSD. Then we are unstaking 1 sfrxUSD on Arbitrum mainnet to receive 1 frxUSD back. Follow the steps below to perform the staking and unstaking:

### **1\. Approve frxUSD and sfrxUSD**

Before staking or unstaking, approve frxUSD for the Hop contract so it can pull frxUSD and sfrxUSD from your wallet:  
async function approveForStakingOrUnstaking(tokenAddress, amount) {  console.log(\`Approving frxUSD for staking on Arbitrum mainnet...\`);  const approveTx \= await arbitrumWalletClient.sendTransaction({    to: tokenAddress,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ARBITRUM\_MAINNET\_HOP\_ADDRESS, amount\],    }),  });  console.log(\`Arbitrum mainnet frxUSD Approval Tx: ${approveTx}\`);} async function approveFrxusdForStaking() {  await approveForStakingOrUnstaking(ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS, STAKE\_AMOUNT);} async function approveSfrxusdForUnstaking() {  await approveForStakingOrUnstaking(ARBITRUM\_MAINNET\_SFRXUSD\_ADDRESS, UNSTAKE\_AMOUNT);}

### **2\. Retrieve FraxZero Quotes**

In this step, you call the quote function on the RemoteHop contract deployed on Arbitrum mainnet to get the native fee amounts required for the staking and unstaking operations. You specify the following parameters:

* OFT: The contract address of the frxUSD token being staked or the sfrxUSD token being unstaked  
* Destination address: The wallet address that will receive the frxUSD or sfrxUSD (in bytes32 format)  
* Amount: The amount of frxUSD to stake or the amount of sfrxUSD to unstake (in wei)

The quote function returns the native fee amount required for the staking and unstaking operations.  
async function retrieveQuote(tokenAddress, amount) {  console.log('Retrieving quote...');  const quote \= await arbitrumPublicClient.readContract({    address: ARBITRUM\_MAINNET\_HOP\_ADDRESS,    abi: \[      {        inputs: \[          { internalType: 'address', name: '\_oft', type: 'address' },          { internalType: 'bytes32', name: '\_to', type: 'bytes32' },          { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },        \],        name: 'quote',        outputs: \[          {            components: \[              { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },              { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },            \],            internalType: 'struct MessagingFee',            name: 'fee',            type: 'tuple',          },        \],        stateMutability: 'view',        type: 'function',      },    \],    functionName: 'quote',    args: \[      tokenAddress,      DESTINATION\_ADDRESS\_BYTES32, // Use bytes32 format      amount,    \],  });  const nativeFee \= quote.nativeFee;  return nativeFee;}

### **3\. Stake and unstake frxUSD**

After approving frxUSD and retrieving the FraxZero quote, stake or unstake by calling the Hop contract's mintRedeem function to receive sfrxUSD or frxUSD back:  
async function stakeOrUnstakeFrxusd(tokenAddress, amount) {  console.log(\`Staking frxUSD for sfrxUSD on Arbitrum mainnet...\`);  const nativeFee \= await retrieveQuote(tokenAddress, amount);  const txHash \= await arbitrumWalletClient.sendTransaction({    to: ARBITRUM\_MAINNET\_HOP\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'address', name: '\_oft', type: 'address' },            { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },          \],          name: 'mintRedeem',          outputs: \[\],          stateMutability: 'payable',          type: 'function',        },      \],      functionName: 'mintRedeem',      args: \[tokenAddress, amount\],    }),    value: nativeFee,  });  console.log(\`Arbitrum mainnet Stake Tx: ${txHash}\`);} async function stakeFrxusd() {  await stakeOrUnstakeFrxusd(ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS, STAKE\_AMOUNT);} async function unstakeFrxusd() {  await stakeOrUnstakeFrxusd(ARBITRUM\_MAINNET\_SFRXUSD\_ADDRESS, UNSTAKE\_AMOUNT);}

## **Build the script**

Create a stake-and-unstake.js file in your project directory and paste the following complete script:

### **stake-and-unstake.js**

import 'dotenv/config';import {  createWalletClient,  http,  encodeFunctionData,  nonceManager,  createPublicClient,} from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { arbitrum } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // FILL IN THE FOLLOWING VARIABLEconst DESTINATION\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Recipient addressconst DESTINATION\_ADDRESS\_BYTES32 \= \`0x000000000000000000000000${DESTINATION\_ADDRESS.slice(  2,)}\`; // Convert to bytes32 format // Hop Contract Addressconst ARBITRUM\_MAINNET\_HOP\_ADDRESS \= '0xa46A266dCBf199a71532c76967e200994C5A0D6d'; // frxUSD and sfrxUSD Contract Addressesconst ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS \= '0x80Eede496655FB9047dd39d9f418d5483ED600df';const ARBITRUM\_MAINNET\_SFRXUSD\_ADDRESS \= '0x5Bff88cA1442c2496f7E475E9e7786383Bc070c0'; // Staking Parametersconst STAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals)const UNSTAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 sfrxUSD (18 decimals) // Set up wallet clientconst arbitrumWalletClient \= createWalletClient({  chain: arbitrum,  transport: http(),  account,}); // Set up public clientconst arbitrumPublicClient \= createPublicClient({  chain: arbitrum,  transport: http(),}); async function approveForStakingOrUnstaking(tokenAddress, amount) {  console.log(\`Approving frxUSD for staking on Arbitrum mainnet...\`);  const approveTx \= await arbitrumWalletClient.sendTransaction({    to: tokenAddress,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ARBITRUM\_MAINNET\_HOP\_ADDRESS, amount\],    }),  });  console.log(\`Arbitrum mainnet frxUSD Approval Tx: ${approveTx}\`);} async function approveFrxusdForStaking() {  await approveForStakingOrUnstaking(ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS, STAKE\_AMOUNT);} async function approveSfrxusdForUnstaking() {  await approveForStakingOrUnstaking(ARBITRUM\_MAINNET\_SFRXUSD\_ADDRESS, UNSTAKE\_AMOUNT);} async function retrieveQuote(tokenAddress, amount) {  console.log('Retrieving quote...');  const quote \= await arbitrumPublicClient.readContract({    address: ARBITRUM\_MAINNET\_HOP\_ADDRESS,    abi: \[      {        inputs: \[          { internalType: 'address', name: '\_oft', type: 'address' },          { internalType: 'bytes32', name: '\_to', type: 'bytes32' },          { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },        \],        name: 'quote',        outputs: \[          {            components: \[              { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },              { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },            \],            internalType: 'struct MessagingFee',            name: 'fee',            type: 'tuple',          },        \],        stateMutability: 'view',        type: 'function',      },    \],    functionName: 'quote',    args: \[      tokenAddress,      DESTINATION\_ADDRESS\_BYTES32, // Use bytes32 format      amount,    \],  });  const nativeFee \= quote.nativeFee;  return nativeFee;} async function stakeOrUnstakeFrxusd(tokenAddress, amount) {  console.log(\`Staking frxUSD for sfrxUSD on Arbitrum mainnet...\`);  const nativeFee \= await retrieveQuote(tokenAddress, amount);  const txHash \= await arbitrumWalletClient.sendTransaction({    to: ARBITRUM\_MAINNET\_HOP\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'address', name: '\_oft', type: 'address' },            { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },          \],          name: 'mintRedeem',          outputs: \[\],          stateMutability: 'payable',          type: 'function',        },      \],      functionName: 'mintRedeem',      args: \[tokenAddress, amount\],    }),    value: nativeFee,  });  console.log(\`Arbitrum mainnet Stake Tx: ${txHash}\`);} async function stakeFrxusd() {  await stakeOrUnstakeFrxusd(ARBITRUM\_MAINNET\_FRXUSD\_ADDRESS, STAKE\_AMOUNT);} async function unstakeSfrxusd() {  await stakeOrUnstakeFrxusd(ARBITRUM\_MAINNET\_SFRXUSD\_ADDRESS, UNSTAKE\_AMOUNT);} // \============ Main \============async function main() {  if (DESTINATION\_ADDRESS \=== 'enter-your-recipient-wallet-address-here') {    console.error(      'Destination address is not set. Please set the DESTINATION\_ADDRESS variable in the transfer.js file.',    );    process.exit(1);  }  const command \= process.argv\[2\];  switch (command) {    case 'stake-frxusd':      console.log('Staking frxusd for sfrxusd...');      await approveFrxusdForStaking();      await stakeFrxusd();      break;    case 'unstake-sfrxusd':      console.log('Unstaking sfrxusd for frxusd...');      await approveSfrxusdForUnstaking();      await unstakeSfrxusd();      break;    default:      console.error('Invalid command. Please use "stake-frxusd" or "unstake-sfrxusd".');      process.exit(1);  }  console.log('Transaction completed\!');} main().catch(console.error);

## **Test the script**

To test staking frxUSD for sfrxUSD, run the following command:  
node stake-and-unstake.js stake-frxusd

To test unstaking sfrxUSD for frxUSD, run the following command:  
node stake-and-unstake.js unstake-sfrxusd

Once each script runs and the staking and unstaking operations are finalized, the confirmation receipts are logged in the console.

## **What's next**

* [Stake & Unstake frxUSD on Ethereum](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-ethereum)  
* [Stake & Unstake frxUSD on Fraxtal](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-fraxtal)  
* 

# **Stake & Unstake frxUSD on Ethereum**

This guide shows how to use the viem framework to stake frxUSD for sfrxUSD and unstake sfrxUSD back to frxUSD on Ethereum mainnet.

To see a list of all supported networks, see the [Stake & Unstake Supported Networks and EIDs](https://docs.frax.com/frxusd/stake-and-unstake-supported-networks) page.

Note: The method for staking and unstaking frxUSD on Ethereum mainnet is different from the method for staking and unstaking frxUSD on Fraxtal and all other EVM chains. See the [Stake & Unstake frxUSD on EVM chains](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-evm-chains) or the [Stake & Unstake frxUSD on Fraxtal](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-fraxtal) guide for more information.

## **Prerequisites**

Before you start building the sample app to perform frxUSD staking operations, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Ethereum mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token on the chain you want to stake from  
   * For this guide, we will be staking and unstaking frxUSD on Ethereum mainnet. Therefore, you will need to fund your wallet with ETH on Ethereum mainnet.  
4. Fund your wallet with frxUSD and sfrxUSD on the chain you want to stake and unstake from  
   * For this guide, we will be staking and unstaking frxUSD on Ethereum mainnet. Therefore, you will need to fund your wallet with frxUSD and sfrxUSD on Ethereum mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-staking-ethereumcd frxusd-staking-ethereumnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frxusd-staking-ethereum",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node stake-and-unstake.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the staking script, including defining contract addresses for Ethereum mainnet and configuring the wallet client.

### **1\. Replace with your private key and wallet address**

Ensure that this section of the file includes your private key for PRIVATE\_KEY and associated wallet address for DESTINATION\_ADDRESS.

The script also predefines the Hop contract address, the Ethereum lockbox contract address, the frxUSD contract address, the sfrxUSD contract address, the staking amount, and the unstaking amount. These definitions are critical for successfully staking and unstaking frxUSD.  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // FILL IN THE FOLLOWING VARIABLEconst DESTINATION\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Recipient addressconst DESTINATION\_ADDRESS\_BYTES32 \= \`0x000000000000000000000000${DESTINATION\_ADDRESS.slice(2)}\`; // Convert to bytes32 format // Hop Contract Addressconst ETHEREUM\_MAINNET\_HOP\_ADDRESS \= '0x99b5587ab54a49e3f827d10175caf69c0187bfa8'; // Ethereum Lockbox Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_LOCKBOX\_ADDRESS \=  '0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0';const ETHEREUM\_MAINNET\_SFRXUSD\_LOCKBOX\_ADDRESS \=  '0x7311cea93ccf5f4f7b789ee31eba5d9b9290e126'; // frxUSD and sfrxUSD Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29';const ETHEREUM\_MAINNET\_SFRXUSD\_ADDRESS \= '0xcf62F905562626CfcDD2261162a51fd02Fc9c5b6'; // Staking Parametersconst STAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals)const UNSTAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 sfrxUSD (18 decimals)

### **2\. Set up clients**

The script creates a wallet client and a public client for Ethereum network:  
// Set up wallet clientconst ethereumWalletClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); // Set up public clientconst ethereumPublicClient \= createPublicClient({  chain: mainnet,  transport: http(),});

## **frxUSD staking and unstaking process**

The following sections outline the relevant staking and unstaking logic of the sample script. In this example, we are first staking 1 frxUSD on Ethereum mainnet to receive 1 sfrxUSD. Then we are unstaking 1 sfrxUSD on Ethereum mainnet to receive 1 frxUSD back. Follow the steps below to perform the staking and unstaking:

### **1\. Approve frxUSD and sfrxUSD**

Before staking or unstaking, approve frxUSD for the Hop contract so it can pull frxUSD and sfrxUSD from your wallet:  
async function approveForStakingOrUnstaking(tokenAddress, amount) {  console.log(\`Approving frxUSD for staking on Ethereum mainnet...\`);  const approveTx \= await ethereumWalletClient.sendTransaction({    to: tokenAddress,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_HOP\_ADDRESS, amount\],    }),  });  console.log(\`Ethereum mainnet frxUSD Approval Tx: ${approveTx}\`);} async function approveFrxusdForStaking() {  await approveForStakingOrUnstaking(ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS, STAKE\_AMOUNT);} async function approveSfrxusdForUnstaking() {  await approveForStakingOrUnstaking(ETHEREUM\_MAINNET\_SFRXUSD\_ADDRESS, UNSTAKE\_AMOUNT);}

### **2\. Retrieve FraxZero Quotes**

In this step, you call the quote function on the RemoteHop contract deployed on Ethereum mainnet to get the native fee amounts required for the staking and unstaking operations. You specify the following parameters:

* OFT: The ethereum lockbox contract address  
* Destination address: The wallet address that will receive the frxUSD or sfrxUSD (in bytes32 format)  
* Amount: The amount of frxUSD to stake or the amount of sfrxUSD to unstake (in wei)

The quote function returns the native fee amount required for the staking and unstaking operations.  
async function retrieveQuote(lockboxAddress, amount) {  console.log('Retrieving quote...');  const quote \= await ethereumPublicClient.readContract({    address: ETHEREUM\_MAINNET\_HOP\_ADDRESS,    abi: \[      {        inputs: \[          { internalType: 'address', name: '\_oft', type: 'address' },          { internalType: 'bytes32', name: '\_to', type: 'bytes32' },          { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },        \],        name: 'quote',        outputs: \[          {            components: \[              { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },              { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },            \],            internalType: 'struct MessagingFee',            name: 'fee',            type: 'tuple',          },        \],        stateMutability: 'view',        type: 'function',      },    \],    functionName: 'quote',    args: \[      lockboxAddress,      DESTINATION\_ADDRESS\_BYTES32, // Use bytes32 format      amount,    \],  });  const nativeFee \= quote.nativeFee;  return nativeFee;}

### **3\. Stake and unstake frxUSD**

After approving frxUSD and retrieving the FraxZero quote, stake or unstake by calling the Hop contract's mintRedeem function to receive sfrxUSD or frxUSD back:  
async function stakeOrUnstakeFrxusd(lockboxAddress, amount) {  console.log(\`Staking frxUSD for sfrxUSD on Ethereum mainnet...\`);  const nativeFee \= await retrieveQuote(lockboxAddress, amount);  const txHash \= await ethereumWalletClient.sendTransaction({    to: ETHEREUM\_MAINNET\_HOP\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'address', name: '\_oft', type: 'address' },            { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },          \],          name: 'mintRedeem',          outputs: \[\],          stateMutability: 'payable',          type: 'function',        },      \],      functionName: 'mintRedeem',      args: \[lockboxAddress, amount\],    }),    value: nativeFee,  });  console.log(\`Ethereum mainnet Stake Tx: ${txHash}\`);} async function stakeFrxusd() {  await stakeOrUnstakeFrxusd(ETHEREUM\_MAINNET\_FRXUSD\_LOCKBOX\_ADDRESS, STAKE\_AMOUNT);} async function unstakeFrxusd() {  await stakeOrUnstakeFrxusd(ETHEREUM\_MAINNET\_SFRXUSD\_LOCKBOX\_ADDRESS, UNSTAKE\_AMOUNT);}

## **Build the script**

Create a stake-and-unstake.js file in your project directory and paste the following complete script:

### **stake-and-unstake.js**

import 'dotenv/config';import {  createWalletClient,  http,  encodeFunctionData,  nonceManager,  createPublicClient,} from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { mainnet } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // FILL IN THE FOLLOWING VARIABLEconst DESTINATION\_ADDRESS \= 'enter-your-recipient-wallet-address-here'; // Recipient addressconst DESTINATION\_ADDRESS\_BYTES32 \= \`0x000000000000000000000000${DESTINATION\_ADDRESS.slice(2)}\`; // Convert to bytes32 format // Hop Contract Addressconst ETHEREUM\_MAINNET\_HOP\_ADDRESS \= '0x99b5587ab54a49e3f827d10175caf69c0187bfa8'; // Ethereum Lockbox Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_LOCKBOX\_ADDRESS \=  '0x566a6442a5a6e9895b9dca97cc7879d632c6e4b0';const ETHEREUM\_MAINNET\_SFRXUSD\_LOCKBOX\_ADDRESS \=  '0x7311cea93ccf5f4f7b789ee31eba5d9b9290e126'; // frxUSD and sfrxUSD Contract Addressesconst ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS \= '0xCAcd6fd266aF91b8AeD52aCCc382b4e165586E29';const ETHEREUM\_MAINNET\_SFRXUSD\_ADDRESS \= '0xcf62F905562626CfcDD2261162a51fd02Fc9c5b6'; // Staking Parametersconst STAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals)const UNSTAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 sfrxUSD (18 decimals) // Set up wallet clientconst ethereumWalletClient \= createWalletClient({  chain: mainnet,  transport: http(),  account,}); // Set up public clientconst ethereumPublicClient \= createPublicClient({  chain: mainnet,  transport: http(),}); async function approveForStakingOrUnstaking(tokenAddress, amount) {  console.log(\`Approving frxUSD for staking on Ethereum mainnet...\`);  const approveTx \= await ethereumWalletClient.sendTransaction({    to: tokenAddress,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[ETHEREUM\_MAINNET\_HOP\_ADDRESS, amount\],    }),  });  console.log(\`Ethereum mainnet frxUSD Approval Tx: ${approveTx}\`);} async function approveFrxusdForStaking() {  await approveForStakingOrUnstaking(ETHEREUM\_MAINNET\_FRXUSD\_ADDRESS, STAKE\_AMOUNT);} async function approveSfrxusdForUnstaking() {  await approveForStakingOrUnstaking(ETHEREUM\_MAINNET\_SFRXUSD\_ADDRESS, UNSTAKE\_AMOUNT);} async function retrieveQuote(lockboxAddress, amount) {  console.log('Retrieving quote...');  const quote \= await ethereumPublicClient.readContract({    address: ETHEREUM\_MAINNET\_HOP\_ADDRESS,    abi: \[      {        inputs: \[          { internalType: 'address', name: '\_oft', type: 'address' },          { internalType: 'bytes32', name: '\_to', type: 'bytes32' },          { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },        \],        name: 'quote',        outputs: \[          {            components: \[              { internalType: 'uint256', name: 'nativeFee', type: 'uint256' },              { internalType: 'uint256', name: 'lzTokenFee', type: 'uint256' },            \],            internalType: 'struct MessagingFee',            name: 'fee',            type: 'tuple',          },        \],        stateMutability: 'view',        type: 'function',      },    \],    functionName: 'quote',    args: \[      lockboxAddress,      DESTINATION\_ADDRESS\_BYTES32, // Use bytes32 format      amount,    \],  });  const nativeFee \= quote.nativeFee;  return nativeFee;} async function stakeOrUnstakeFrxusd(lockboxAddress, amount) {  console.log(\`Staking frxUSD for sfrxUSD on Ethereum mainnet...\`);  const nativeFee \= await retrieveQuote(lockboxAddress, amount);  const txHash \= await ethereumWalletClient.sendTransaction({    to: ETHEREUM\_MAINNET\_HOP\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'address', name: '\_oft', type: 'address' },            { internalType: 'uint256', name: '\_amountLD', type: 'uint256' },          \],          name: 'mintRedeem',          outputs: \[\],          stateMutability: 'payable',          type: 'function',        },      \],      functionName: 'mintRedeem',      args: \[lockboxAddress, amount\],    }),    value: nativeFee,  });  console.log(\`Ethereum mainnet Stake Tx: ${txHash}\`);} async function stakeFrxusd() {  await stakeOrUnstakeFrxusd(ETHEREUM\_MAINNET\_FRXUSD\_LOCKBOX\_ADDRESS, STAKE\_AMOUNT);} async function unstakeSfrxusd() {  await stakeOrUnstakeFrxusd(ETHEREUM\_MAINNET\_SFRXUSD\_LOCKBOX\_ADDRESS, UNSTAKE\_AMOUNT);} // \============ Main \============async function main() {  if (DESTINATION\_ADDRESS \=== 'enter-your-recipient-wallet-address-here') {    console.error(      'Destination address is not set. Please set the DESTINATION\_ADDRESS variable in the transfer.js file.',    );    process.exit(1);  }  const command \= process.argv\[2\];  switch (command) {    case 'stake-frxusd':      console.log('Staking frxusd for sfrxusd...');      await approveFrxusdForStaking();      await stakeFrxusd();      break;    case 'unstake-sfrxusd':      console.log('Unstaking sfrxusd for frxusd...');      await approveSfrxusdForUnstaking();      await unstakeSfrxusd();      break;    default:      console.error('Invalid command. Please use "stake-frxusd" or "unstake-sfrxusd".');      process.exit(1);  }  console.log('Transaction completed\!');} main().catch(console.error);

## **Test the script**

To test staking frxUSD for sfrxUSD, run the following command:  
node stake-and-unstake.js stake-frxusd

To test unstaking sfrxUSD for frxUSD, run the following command:  
node stake-and-unstake.js unstake-sfrxusd

Once each script runs and the staking and unstaking operations are finalized, the confirmation receipts are logged in the console.

## **What's next**

* [Stake & Unstake frxUSD on Fraxtal](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-fraxtal)  
* 

# **Stake & Unstake frxUSD on Fraxtal**

This guide shows how to use the viem framework to stake frxUSD for sfrxUSD and unstake sfrxUSD back to frxUSD on Fraxtal mainnet.

To see a list of all supported networks, see the [Stake & Unstake Supported Networks and EIDs](https://docs.frax.com/frxusd/stake-and-unstake-supported-networks) page.

Note: The method for staking and unstaking frxUSD on Fraxtal is different from the method for staking and unstaking frxUSD on all other EVM chains. See the [Stake & Unstake frxUSD on EVM chains](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-evm-chains) and [Stake & Unstake frxUSD on Ethereum](https://docs.frax.com/frxusd/stake-and-unstake-quickstart-ethereum) guides for more information.

## **Prerequisites**

Before you start building the sample app to perform frxUSD staking operations, ensure you have met the following prerequisites:

1. Install Node.js and npm  
   * Download and install Node.js directly or use a version manager like nvm.  
   * npm is included with Node.js.  
2. Set up a non-custodial wallet (for example, MetaMask)  
   * You can download, install, and create a MetaMask wallet from its official website.  
   * During setup, create a wallet on Fraxtal mainnet.  
   * Retrieve the private key for your wallet, as it will be required in the script below.  
3. Fund your wallet with the gas token on Fraxtal  
   * For this guide, we will be staking and unstaking frxUSD on Fraxtal mainnet. Therefore, you will need to fund your wallet with FRAX on Fraxtal mainnet.  
4. Fund your wallet with frxUSD and sfrxUSD on the chain you want to stake and unstake from  
   * For this guide, we will be staking and unstaking frxUSD on Fraxtal mainnet. Therefore, you will need to fund your wallet with frxUSD and sfrxUSD on Fraxtal mainnet.

## **Project setup**

To build the script, first set up your project environment and install the required dependencies.

### **1\. Set up a new project**

Create a new directory and initialize a new Node.js project with default settings:  
mkdir frxusd-staking-fraxtalcd frxusd-staking-fraxtalnpm init \-y

This also creates a default package.json file.

### **2\. Install dependencies**

In your project directory, install the required dependencies, including viem:  
npm install dotenv@^16.4.7 viem@^2.23.4

This sets up your development environment with the necessary libraries for building the script. It also updates the package.json file with the dependencies.

### **3\. Add module type**

Add "type": "module" to the package.json file:  
{  "name": "frxusd-staking-fraxtal",  "version": "1.0.0",  "type": "module",  "main": "index.js",  "scripts": {    "test": "echo \\"Error: no test specified\\" && exit 1",    "start": "node stake-and-unstake.js"  },  "keywords": \[\],  "author": "",  "license": "ISC",  "description": "",  "dependencies": {    "dotenv": "^16.4.7",    "viem": "^2.23.4"  }}

### **4\. Configure environment variables**

Create a .env file in your project directory and add your wallet private key:  
echo "PRIVATE\_KEY=your-private-key-here" \> .env

Warning: This is strictly for testing purposes. Never share your private key.

## **Script setup**

This section covers the necessary setup for the staking script, including defining contract addresses for Fraxtal mainnet and configuring the wallet client.

### **1\. Contract addresses and configuration**

The script defines addresses for Fraxtal mainnet:  
// \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // frxUSD Stake & Unstake Contract Address (Fraxtal)const FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS \= '0xBFc4D34Db83553725eC6c768da71D2D9c1456B55'; // frxUSD and sfrxUSD Contract Addressesconst FRAXTAL\_FRXUSD\_ADDRESS \= '0xfc00000000000000000000000000000000000001';const FRAXTAL\_SFRXUSD\_ADDRESS \= '0xfc00000000000000000000000000000000000008'; // Staking Parametersconst STAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals)const UNSTAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 sfrxUSD (18 decimals)

### **2\. Set up wallet client**

The script creates a wallet client for Fraxtal network:  
// Set up wallet client for Fraxtal networkconst fraxtalClient \= createWalletClient({  chain: fraxtal,  transport: http(),  account,});

## **frxUSD staking process**

The following sections outline the staking and unstaking logic for Fraxtal network. The process involves:

1. Approving frxUSD for the frxUSD Stake & Unstake contract to stake frxUSD  
2. Staking frxUSD to receive sfrxUSD using the deposit function  
3. Approving sfrxUSD for the frxUSD Stake & Unstake contract to unstake sfrxUSD  
4. Unstaking sfrxUSD to receive frxUSD back using the redeem function

### **1\. Approve frxUSD for staking**

Before staking, approve frxUSD for the frxUSD Stake & Unstake contract so it can pull frxUSD from your wallet:  
async function approveFrxusdForStaking() {  console.log(\`Approving frxUSD for staking on Fraxtal...\`);  const approveTx \= await fraxtalClient.sendTransaction({    to: FRAXTAL\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS, STAKE\_AMOUNT\],    }),  });  console.log(\`Fraxtal frxUSD Approval Tx: ${approveTx}\`);}

### **2\. Stake frxUSD for sfrxUSD**

After approving frxUSD, stake by calling the frxUSD Stake & Unstake contract's deposit function to receive sfrxUSD:  
async function stakeFrxusd() {  console.log(\`Staking frxUSD for sfrxUSD on Fraxtal...\`);  const txHash \= await fraxtalClient.sendTransaction({    to: FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[STAKE\_AMOUNT, account.address\],    }),  });  console.log(\`Fraxtal Stake Tx: ${txHash}\`);}

### **3\. Approve sfrxUSD for unstaking**

Before unstaking, approve sfrxUSD for the same contract so it can pull sfrxUSD:  
async function approveSfrxusdForUnstaking() {  console.log(\`Approving sfrxUSD for unstaking on Fraxtal...\`);  const approveTx \= await fraxtalClient.sendTransaction({    to: FRAXTAL\_SFRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS, UNSTAKE\_AMOUNT\],    }),  });  console.log(\`Fraxtal sfrxUSD Approval Tx: ${approveTx}\`);}

### **4\. Unstake sfrxUSD for frxUSD**

After approving sfrxUSD, unstake by calling the frxUSD Stake & Unstake contract's redeem function to receive frxUSD back:  
async function unstakeSfrxusd() {  console.log(\`Unstaking sfrxUSD for frxUSD on Fraxtal...\`);  const txHash \= await fraxtalClient.sendTransaction({    to: FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[UNSTAKE\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Fraxtal Unstake Tx: ${txHash}\`);}

## **Build the script**

Create a stake-and-unstake.js file in your project directory and paste the following complete script:

### **stake-and-unstake.js**

// \============ Setup (imports, account, clients) \============import 'dotenv/config';import { createWalletClient, http, encodeFunctionData, nonceManager } from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { fraxtal } from 'viem/chains'; // \============ Configuration Constants \============ // Authenticationconst PRIVATE\_KEY \= process.env.PRIVATE\_KEY;const account \= privateKeyToAccount(\`0x${PRIVATE\_KEY}\`, { nonceManager }); // frxUSD Stake & Unstake Contract Address (Fraxtal)const FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS \= '0xBFc4D34Db83553725eC6c768da71D2D9c1456B55'; // frxUSD and sfrxUSD Contract Addressesconst FRAXTAL\_FRXUSD\_ADDRESS \= '0xfc00000000000000000000000000000000000001';const FRAXTAL\_SFRXUSD\_ADDRESS \= '0xfc00000000000000000000000000000000000008'; // Staking Parametersconst STAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 frxUSD (18 decimals)const UNSTAKE\_AMOUNT \= 10\_000\_000\_000\_000\_000\_000n; // 10 sfrxUSD (18 decimals) // Wallet clientconst fraxtalClient \= createWalletClient({  chain: fraxtal,  transport: http(),  account,}); // \============ Helper Functions \============ // 1\) Approve frxUSD for stakingasync function approveFrxusdForStaking() {  console.log(\`Approving frxUSD for staking on Fraxtal...\`);  const approveTx \= await fraxtalClient.sendTransaction({    to: FRAXTAL\_FRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS, STAKE\_AMOUNT\],    }),  });  console.log(\`Fraxtal frxUSD Approval Tx: ${approveTx}\`);} // 2\) Stake frxUSD for sfrxUSDasync function stakeFrxusd() {  console.log(\`Staking frxUSD for sfrxUSD on Fraxtal...\`);  const txHash \= await fraxtalClient.sendTransaction({    to: FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_assetsIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },          \],          name: 'deposit',          outputs: \[{ internalType: 'uint256', name: '\_sharesOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'deposit',      args: \[STAKE\_AMOUNT, account.address\],    }),  });  console.log(\`Fraxtal Stake Tx: ${txHash}\`);} // 3\) Approve sfrxUSD for unstakingasync function approveSfrxusdForUnstaking() {  console.log(\`Approving sfrxUSD for unstaking on Fraxtal...\`);  const approveTx \= await fraxtalClient.sendTransaction({    to: FRAXTAL\_SFRXUSD\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          type: 'function',          name: 'approve',          stateMutability: 'nonpayable',          inputs: \[            { name: 'spender', type: 'address' },            { name: 'amount', type: 'uint256' },          \],          outputs: \[{ name: '', type: 'bool' }\],        },      \],      functionName: 'approve',      args: \[FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS, UNSTAKE\_AMOUNT\],    }),  });  console.log(\`Fraxtal sfrxUSD Approval Tx: ${approveTx}\`);} // 4\) Unstake sfrxUSD for frxUSDasync function unstakeSfrxusd() {  console.log(\`Unstaking sfrxUSD for frxUSD on Fraxtal...\`);  const txHash \= await fraxtalClient.sendTransaction({    to: FRAXTAL\_FRXUSD\_STAKE\_UNSTAKE\_ADDRESS,    data: encodeFunctionData({      abi: \[        {          inputs: \[            { internalType: 'uint256', name: '\_sharesIn', type: 'uint256' },            { internalType: 'address', name: '\_receiver', type: 'address' },            { internalType: 'address', name: '\_owner', type: 'address' },          \],          name: 'redeem',          outputs: \[{ internalType: 'uint256', name: '\_assetsOut', type: 'uint256' }\],          stateMutability: 'nonpayable',          type: 'function',        },      \],      functionName: 'redeem',      args: \[UNSTAKE\_AMOUNT, account.address, account.address\],    }),  });  console.log(\`Fraxtal Unstake Tx: ${txHash}\`);} // \============ Main \============async function main() {  const command \= process.argv\[2\];  switch (command) {    case 'stake-frxusd':      console.log('Staking frxusd for sfrxusd...');      await approveFrxusdForStaking();      await stakeFrxusd();      break;    case 'unstake-sfrxusd':      console.log('Unstaking sfrxusd for frxusd...');      await approveSfrxusdForUnstaking();      await unstakeSfrxusd();      break;    default:      console.error('Invalid command. Please use "stake-frxusd" or "unstake-sfrxusd".');      process.exit(1);  }  console.log('Staking and unstaking completed\!');} main().catch(console.error);

## **Test the script**

To test the script, run the following command:  
node stake-and-unstake.js

The script will execute staking and unstaking operations on Fraxtal mainnet, logging all transaction hashes to the console.

## **What's next**

* [White-label Stablecoins](https://docs.frax.com/frxusd/white-label-stablecoin-overview)  
* 

